<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Cornel Box</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #c {
        width: 100%;
        height: 100%;
        display: block;
      }

      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display: block;
      }
    </style>
  </head>
  <body>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { VRButton } from "three/addons/webxr/VRButton.js";
      import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";

      /* Main script */
      let camera, globalScene, scene, renderer, controls;

      // Initialize empty scene with cameras and controls
      init();

      // Enable VR
      // setupVR();

      // Create the floor of crosses
      floorOfCrosses(25, 50);

      // Create scene entities
      const cornelBox = createCornelBox();
      const table = createTable();
      const cone = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 32), new THREE.MeshLambertMaterial());
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshPhysicalMaterial());
      const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 32), new THREE.MeshPhongMaterial());

      // Name entities
      table.name = "table";
      cone.name = "coneLambert";
      sphere.name = "spherePhysical";
      cylinder.name = "cylinderPhong";

      // Position the scene entities
      cone.position.set(-3, 6, -1);
      sphere.position.set(0, 6.25, 1);
      cylinder.position.set(3, 6, -1);

      // TODO: CHECK MESHSTANDARDMATERIAL IN 3.JS DOCS

      // Add to the scene
      scene.add(cornelBox);
      scene.add(table);
      scene.add(cone);
      scene.add(sphere);
      scene.add(cylinder);

      // Hide front screen lowerer of the Cornel Box
      scene.getObjectByName("cornelBox_frontCornelFace_screenLowerer").visible = false;

      // Setup the GUI
      setupGUI();

      //! DEBUG ONLY: make everything transparent
      // traverse(cornelBox, enableTransparency);

      // Enable shadows
      traverse(scene.getObjectByName("cornelBox"), enableShadows);
      traverse(scene.getObjectByName("table"), enableShadows);
      traverse(scene.getObjectByName("coneLambert"), enableShadows);
      traverse(scene.getObjectByName("spherePhysical"), enableShadows);
      traverse(scene.getObjectByName("cylinderPhong"), enableShadows);
      const c = scene.getObjectByName("lampCube"); // TODO: fix this
      c.enableShadows = false;
      c.castShadow = false;

      // Render with setAnimationLoop for XR compatibility
      renderer.setAnimationLoop(function (time) {
        // Update controls
        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

        // Conel box wall animation
        animateCornelBox();

        // Render
        renderer.render(scene, camera);
      });
      /* End of main script */

      // Initialize empty scene with renderer, cameras, lights, and controls
      function init() {
        // Global scene
        scene = new THREE.Scene();

        // Renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Shadows

        // Cameras
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 500);
        camera.position.set(0, 10.5, 14);

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window); // optional
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 0;
        controls.maxDistance = 500;
        controls.target = new THREE.Vector3(0, 10, 0);
        // controls.autoRotate = true;
        controls.autoRotateSpeed = 1;

        // Lights
        {
          const color = 0xffffff;
          const intensity = 0.2;
          const light = new THREE.AmbientLight(color, intensity);
          light.name = "ambientLight";
          scene.add(light);
        }

        // Additional setup
        document.body.appendChild(renderer.domElement);

        // Window resize fix
        window.addEventListener("resize", onWindowResize);

        // Add a simple floor
        const floor = new THREE.Mesh(
          new THREE.BoxGeometry(100, 0.01, 100),
          new THREE.MeshBasicMaterial({ color: "gray" })
        );
        scene.add(floor);
        // TODO: fix this, shadows not working for the floor
        floor.enableShadows = true;
        floor.castShadow = true;
      }

      // Create a frame piece (metallic lengthy component with fringes)
      function createFramePiece(length) {
        // Create the frame piece group.
        const framePiece = new THREE.Object3D();

        // Create the materials
        const material = new THREE.MeshLambertMaterial({ color: "#AAAFBA" });

        // Create the corners (perspective: top-view).
        const cornerWidth = 0.21875; // Calculated to sum-up with centers and fringes to 1
        const cornerGeometry = new THREE.BoxGeometry(cornerWidth, length, cornerWidth);
        const bLeftCorner = new THREE.Mesh(cornerGeometry, material);
        const bRightCorner = bLeftCorner.clone();
        const tLeftCorner = bLeftCorner.clone();
        const tRightCorner = bLeftCorner.clone();

        // Create the centers
        const centerWidth = cornerWidth * 2;
        const centerGeometry = new THREE.BoxGeometry(cornerWidth * 2, length, 1);
        const frontCenter = new THREE.Mesh(centerGeometry, material);
        const sideCenter = new THREE.Mesh(centerGeometry, material);

        // Create the filler
        const fillerWidth = 1 - cornerWidth;
        const fillerGeometry = new THREE.BoxGeometry(fillerWidth, length - 0.001, fillerWidth);
        const filler = new THREE.Mesh(fillerGeometry, material);

        // Position the corners
        const cornerPos = 0.5 - cornerWidth / 2;
        bLeftCorner.position.set(-cornerPos, length / 2, cornerPos);
        bRightCorner.position.set(cornerPos, length / 2, cornerPos);
        tLeftCorner.position.set(-cornerPos, length / 2, -cornerPos);
        tRightCorner.position.set(cornerPos, length / 2, -cornerPos);

        // Position the centers
        frontCenter.position.y = length / 2;
        sideCenter.position.y = length / 2;
        sideCenter.rotation.y = Math.PI / 2;

        // Position the filler
        filler.position.y = length / 2;

        // Add corners, centers, and filler to the frame piece
        framePiece.add(bLeftCorner);
        framePiece.add(bRightCorner);
        framePiece.add(tLeftCorner);
        framePiece.add(tRightCorner);
        framePiece.add(frontCenter);
        framePiece.add(sideCenter);
        framePiece.add(filler);
        return framePiece;
      }

      // Create a panel (yellow front face, white back face)
      function createPanel(name = "panel") {
        // Create the panel group
        const panel = new THREE.Object3D();

        // Cornel box measurements
        const fringeLength = 0.0625;
        const cornerWidth = 0.21875;

        // Create the front and back faces according to the cornel box measurements
        const panelGeometry = new THREE.BoxGeometry(28, 3, fringeLength / 2);
        const panelMaterials = [
          // Front and Back
          new THREE.MeshLambertMaterial({ color: "#909B21" }),
          new THREE.MeshLambertMaterial({ color: "#ffffff" }),
        ];
        const panelFront = new THREE.Mesh(panelGeometry, panelMaterials[0]);
        const panelBack = new THREE.Mesh(panelGeometry, panelMaterials[1]);
        panelBack.name = name + "_back";

        // Distance the front and back faces
        panelFront.position.z = fringeLength / 2;
        panelBack.position.z = -fringeLength / 2;

        // Add front and back to the panel group
        panel.add(panelFront);
        panel.add(panelBack);

        return panel;
      }

      // Create a screen lowerer
      function createScreenLowerer(name) {
        // Create the screen lowerer group
        const screenLowerer = new THREE.Object3D();
        screenLowerer.name = name;

        // Cornel box measurements
        const fringeLength = 0.0625;
        const cornerWidth = 0.21875;

        // Create the material
        const material = new THREE.MeshLambertMaterial({ color: "#5F6062" });
        const screenMaterial = new THREE.MeshLambertMaterial({ color: "#ffffff" });

        // Create the top frame
        // TODO: gap for side frame and screen, hole detail in the back face
        const tFrameGeometry = new THREE.BoxGeometry(28, 1, 1);
        const tFrame = new THREE.Mesh(tFrameGeometry, material);

        // Create the side frames of the screen lowerer
        // TODO: side frames have a gap for the screen, with the gap filled with brush hair, and a offset detail
        const sFrameGeometry = new THREE.BoxGeometry(0.5, 24, fringeLength + cornerWidth);
        const lFrame = new THREE.Mesh(sFrameGeometry, material);
        const rFrame = new THREE.Mesh(sFrameGeometry, material);

        // Create the screen
        // TODO: bottom part of the screen is bigger than the screen panel + check calculations
        // TODO: frontface of the panel is black / dark gray, back face is white
        const screen = new THREE.Object3D();
        const screenPanelGeometry = new THREE.BoxGeometry(28 - 2 * cornerWidth, 24 - 2 * cornerWidth, fringeLength / 2);
        const screenBottomGeometry = new THREE.BoxGeometry(28 - 2 * cornerWidth, 2 * cornerWidth, fringeLength);
        const screenPanel = new THREE.Mesh(screenPanelGeometry, screenMaterial);
        const screenBottom = new THREE.Mesh(screenBottomGeometry, material);
        screen.name = name + "_screen";
        screenPanel.name = name + "_screenPanel";
        screenBottom.name = name + "_screenBottom";

        // Position the screen parts
        screenBottom.position.y = cornerWidth;
        screenPanel.position.y = 12 + cornerWidth;

        // Add screen parts to the screen group
        screen.add(screenPanel);
        screen.add(screenBottom);

        // Position the frames and the screen
        const innerFringePosition = -(cornerWidth + fringeLength / 2);
        tFrame.position.y = 24.5;
        lFrame.position.set(-14, 12, innerFringePosition);
        rFrame.position.set(14, 12, innerFringePosition);

        // Add parts to the group
        screenLowerer.add(tFrame);
        screenLowerer.add(lFrame);
        screenLowerer.add(rFrame);
        screenLowerer.add(screenBottom);
        screenLowerer.add(screen);

        return screenLowerer;
      }

      // Create one face of the cornel box
      function createCornelFace(name = "cornelFace") {
        // Create the face group
        const face = new THREE.Object3D();
        face.name = name;

        // Create the frames
        const lFramePiece = createFramePiece(29.5);
        const rFramePiece = createFramePiece(29.5);
        const tFramePiece = createFramePiece(28);
        const bFramePiece = createFramePiece(28);

        // Create the panel
        const panel = createPanel(name + "_panel");

        // Create the screen lowerer
        const screenLowerer = createScreenLowerer(name + "_screenLowerer");

        // Position the frames
        lFramePiece.position.set(-14.5, 0.5, 0);
        rFramePiece.position.set(14.5, 0.5, 0);
        tFramePiece.position.set(-14, 29.5, 0);
        tFramePiece.rotation.z = -Math.PI / 2;
        bFramePiece.position.set(-14, 25.5, 0); // Check the y position calculations
        bFramePiece.rotation.z = -Math.PI / 2;

        // Position the panel on the outermost fringe CHECK CALCULATIONS
        const fringeLength = 0.0625;
        const cornerWidth = 0.21875;
        panel.position.set(0, 27.5, cornerWidth + fringeLength / 2);

        // Add components to the face
        face.add(lFramePiece);
        face.add(rFramePiece);
        face.add(tFramePiece);
        face.add(bFramePiece);
        face.add(panel);
        face.add(screenLowerer);

        return face;
      }

      // Create the roof lamp
      // TODO: make the lamp model
      function createLamp(name = "lamp") {
        // Create the lamp group
        const lamp = new THREE.Object3D();

        // Create a placeholder cube for the lamp
        const lampMaterial = new THREE.MeshLambertMaterial({ color: "#ffffff" });
        const lampGeometry = new THREE.BoxGeometry(1, 1, 1);
        const lampCube = new THREE.Mesh(lampGeometry, lampMaterial);
        lampCube.name = "lampCube";

        // Position the lamp elements
        lampCube.position.y = -1; // Anchor point at the top

        // Directional Light
        const directionalColor = 0xffffff;
        const directionalIntensity = 0.25;
        const directionalLight = new THREE.DirectionalLight(directionalColor, directionalIntensity);
        directionalLight.name = name + "_directionalLight";
        directionalLight.target = scene;
        directionalLight.visible = false;

        // Point light
        const pointColor = 0xffffff;
        const pointIntensity = 0.6;
        const pointDistance = 100;
        const pointDecay = 2;
        const pointLight = new THREE.PointLight(pointColor, pointIntensity, pointDistance, pointDecay);
        pointLight.name = name + "_pointLight";

        // Spotlight
        const spotLight = new THREE.SpotLight(0xffffff, 0.25);
        spotLight.name = name + "_spotLight";
        spotLight.target = scene;
        spotLight.visible = false;

        // Hemisphere light
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.25);
        hemisphereLight.name = name + "_hemisphereLight";

        // Add to the lamp group
        lamp.add(lampCube);
        lamp.add(directionalLight);
        lamp.add(pointLight);
        lamp.add(spotLight);
        lamp.add(hemisphereLight);

        return lamp;
      }

      // Create the roof for the cornel box
      function createCornelRoof(name = "roof") {
        // Create the roof group
        const roof = new THREE.Object3D();

        // Create the upper panel
        const panelGeometry = new THREE.BoxGeometry(28, 0.5, 28);
        const panelMaterial = new THREE.MeshLambertMaterial({ color: "#ffffff" });
        const upperPanel = new THREE.Mesh(panelGeometry, panelMaterial);
        upperPanel.name = name + "_upperPanel";

        // Create the roof frames (h=horizontal, v=vertical, c=center)
        const hLength = 28;
        const vLength = 28 / 3;
        const hFrame1 = createFramePiece(hLength);
        const hFrame2 = createFramePiece(hLength);
        const vFrame1 = createFramePiece(vLength);
        const vFrame2 = createFramePiece(vLength);
        const cFrame1 = createFramePiece(vLength);
        const cFrame2 = createFramePiece(vLength);

        // Create the lamp
        const lamp = createLamp(name + "_lamp");

        // DEBUG
        const axesHelper = new THREE.AxesHelper(5);
        lamp.add(axesHelper);

        // Position the upper panel
        upperPanel.position.y = 0.25;

        // Position the roof frames (y=-0.01 to avoid flickering with panel)
        // TODO: check the calculations. Lengths are too big
        const offset = 0.25; // Offset = half the width of the frame (1)
        hFrame1.rotation.z = Math.PI / 2;
        hFrame1.position.set(hLength / 2, -0.01, vLength / 2 - offset);
        hFrame2.rotation.z = Math.PI / 2;
        hFrame2.position.set(hLength / 2, -0.01, -vLength / 2 + offset);
        vFrame1.rotation.x = Math.PI / 2;
        vFrame1.position.set(-hLength / 4, -0.01, -vLength / 2);
        vFrame2.rotation.x = Math.PI / 2;
        vFrame2.position.set(hLength / 4, -0.01, -vLength / 2);
        cFrame1.rotation.x = Math.PI / 2;
        cFrame1.position.set(0, -0.01, vLength / 2 + offset);
        cFrame2.rotation.x = -Math.PI / 2;
        cFrame2.position.set(0, -0.01, -vLength / 2 - offset);

        // Add to the roof group
        roof.add(upperPanel);
        roof.add(hFrame1);
        roof.add(hFrame2);
        roof.add(vFrame1);
        roof.add(vFrame2);
        roof.add(cFrame1);
        roof.add(cFrame2);
        roof.add(lamp);
        return roof;
      }

      // Create a cornel box based on the Telelumen lighting system in the IXR platform in UJM
      function createCornelBox(name = "cornelBox") {
        // Create the cornel box group
        const cornelBox = new THREE.Object3D();
        cornelBox.name = name;

        // Create the cornel box faces
        const frontFace = createCornelFace(name + "_frontCornelFace");
        const leftFace = createCornelFace(name + "_leftCornelFace");
        const rightFace = createCornelFace(name + "_rightCornelFace");
        const backFace = createCornelFace(name + "_backCornelFace");

        // Create the cornel box roof
        const roof = createCornelRoof(name + "_roof");

        // Position the cornel box elements
        frontFace.position.z = 14.5;
        leftFace.position.x = -14.5;
        rightFace.position.x = 14.5;
        backFace.position.z = -14.5;
        roof.position.y = 29.5;

        // Rotate cornel box elements
        leftFace.rotation.y = -Math.PI / 2;
        rightFace.rotation.y = Math.PI / 2;
        backFace.rotation.y = -Math.PI;

        // Scene graph: build the scene here
        cornelBox.add(frontFace);
        cornelBox.add(leftFace);
        cornelBox.add(rightFace);
        cornelBox.add(backFace);
        cornelBox.add(roof);

        return cornelBox;
      }

      // Animate the cornel box
      function animateCornelBox() {}

      // Create a table
      function createTable() {
        // Create the table group
        const table = new THREE.Object3D();
        table.name = "name";

        // Create the material
        const material = new THREE.MeshLambertMaterial({ color: "#808080" });

        // Create the top
        const topGeometry = new THREE.BoxGeometry(10, 0.5, 5);
        const top = new THREE.Mesh(topGeometry, material);

        // Create the legs
        const legGeometry = new THREE.BoxGeometry(0.5, 5, 0.5);
        const lLeg1 = new THREE.Mesh(legGeometry, material);
        const lLeg2 = new THREE.Mesh(legGeometry, material);
        const rLeg1 = new THREE.Mesh(legGeometry, material);
        const rLeg2 = new THREE.Mesh(legGeometry, material);

        // Position the table elements
        top.position.y = 5;
        lLeg1.position.set(-4.5, 2.5, -2);
        lLeg2.position.set(-4.5, 2.5, 2);
        rLeg1.position.set(4.5, 2.5, -2);
        rLeg2.position.set(4.5, 2.5, 2);

        // Fix legs to the table
        table.add(top);
        table.add(lLeg1);
        table.add(lLeg2);
        table.add(rLeg1);
        table.add(rLeg2);

        return table;
      }

      // Setup the GUI
      function setupGUI() {
        // Top level controller
        const gui = new GUI({ title: "Cornel Settings" });

        // Get references
        const frontPanel = scene.getObjectByName("cornelBox_frontCornelFace_screenLowerer_screenPanel");
        const leftPanel = scene.getObjectByName("cornelBox_leftCornelFace_screenLowerer_screenPanel");
        const rightPanel = scene.getObjectByName("cornelBox_rightCornelFace_screenLowerer_screenPanel");
        const backPanel = scene.getObjectByName("cornelBox_backCornelFace_screenLowerer_screenPanel");
        const frontScreenLowerer = scene.getObjectByName("cornelBox_frontCornelFace_screenLowerer");
        const leftScreenLowerer = scene.getObjectByName("cornelBox_leftCornelFace_screenLowerer");
        const rightScreenLowerer = scene.getObjectByName("cornelBox_rightCornelFace_screenLowerer");
        const backScreenLowerer = scene.getObjectByName("cornelBox_backCornelFace_screenLowerer");
        const frontTopPanel = scene.getObjectByName("cornelBox_frontCornelFace_panel_back");
        const leftTopPanel = scene.getObjectByName("cornelBox_leftCornelFace_panel_back");
        const rightTopPanel = scene.getObjectByName("cornelBox_rightCornelFace_panel_back");
        const backTopPanel = scene.getObjectByName("cornelBox_backCornelFace_panel_back");
        const roofPanel = scene.getObjectByName("cornelBox_roof_upperPanel");
        const directionalLight = scene.getObjectByName("cornelBox_roof_lamp_directionalLight");
        const pointLight = scene.getObjectByName("cornelBox_roof_lamp_pointLight");
        const spotLight = scene.getObjectByName("cornelBox_roof_lamp_spotLight");
        const hemisphereLight = scene.getObjectByName("cornelBox_roof_lamp_hemisphereLight");
        const coneLambert = scene.getObjectByName("coneLambert");
        const spherePhysical = scene.getObjectByName("spherePhysical");
        const cylinderPhong = scene.getObjectByName("cylinderPhong");

        // Example textures
        const exampleTexture = new THREE.TextureLoader().load("textures/grenouille.jpg");
        const exampleGrayTexture = new THREE.TextureLoader().load("textures/grenouille-gray.jpg");

        // Settings for the gui
        const settings = {
          // Enable/disable screen lowerers
          enableFrontScreenLowerer: frontScreenLowerer.visible,
          enableLeftScreenLowerer: leftScreenLowerer.visible,
          enableRightScreenLowerer: rightScreenLowerer.visible,
          enableBackScreenLowerer: backScreenLowerer.visible,

          // Panel material
          frontPanelColor: frontPanel.material.color,
          leftPanelColor: leftPanel.material.color,
          rightPanelColor: rightPanel.material.color,
          backPanelColor: backPanel.material.color,
          roofPanel: roofPanel.material.color,

          // Checkboxes for enabling different types of lights
          directionalLightEnable: directionalLight.visible,
          pointLightEnable: pointLight.visible,
          spotLightEnable: spotLight.visible,
          hemisphereLightEnable: hemisphereLight.visible,

          // Light intensities
          directionalLightIntensity: directionalLight.intensity,
          pointLightIntensity: pointLight.intensity,
          spotLightIntensity: spotLight.intensity,
          hemisphereLightIntensity: hemisphereLight.intensity,

          // Light colors
          directionalLightColor: directionalLight.color,
          pointLightColor: pointLight.color,
          spotLightColor: spotLight.color,
          hemisphereLightColor: hemisphereLight.color,

          // Directional light specific settings
          directionalLightCastShadow: directionalLight.castShadow,
          directionalLightTarget: directionalLight.target,

          // Point light specific settings
          pointLightCastShadow: pointLight.castShadow,
          pointLightDecay: pointLight.decay,
          pointLightDistance: pointLight.distance,
          pointLightPower: pointLight.power,

          // Spot light specific settings
          spotLightAngle: spotLight.angle * (180 / Math.PI),
          spotLightCastShadow: spotLight.castShadow,
          spotLightDecay: spotLight.decay,
          spotLightDistance: spotLight.distance,
          spotLightPenumbra: spotLight.penumbra,
          spotLightPower: spotLight.power,
          spotLightTarget: spotLight.target,
          spotLightMap: spotLight.map,

          // Hemisphere light specific settings
          hemisphereLightGroundColor: hemisphereLight.groundColor,

          // THREE.Material properties
          materialsAlphaTest: coneLambert.material.alphaTest,
          materialsAlphaToCoverage: coneLambert.material.alphaToCoverage,
          materialsBlendDst: coneLambert.material.blendDst,
          materialsBlendDstAlpha: 0, // coneLambert.material.blendDstAlpha is null and crashes
          materialsBlendEquation: coneLambert.material.blendEquation,
          materialsBlendEquationAlpha: 0, // coneLambert.material.blendEquationAlpha is null and crashes
          materialsBlending: coneLambert.material.blending,
          materialsBlendSrc: coneLambert.material.blendSrc,
          materialsBlendSrcAlpha: 0, // coneLambert.material.blendSrcAlpha is null and crashes
          materialsClipIntersection: coneLambert.material.clipIntersection,
          materialsClipShadows: coneLambert.material.clipShadows,
          materialsColorWrite: coneLambert.material.colorWrite,
          materialsDepthFunc: coneLambert.material.depthFunc,
          materialsDepthTest: coneLambert.material.depthTest,
          materialsDepthWrite: coneLambert.material.depthWrite,
          materialsStencilWrite: coneLambert.material.stencilWrite,
          materialsStencilWriteMask: coneLambert.material.stencilWriteMask,
          materialsStencilFunc: coneLambert.material.stencilFunc,
          materialsStencilRef: coneLambert.material.stencilRef,
          materialsStencilFuncMask: coneLambert.material.stencilFuncMask,
          materialsStencilFail: coneLambert.material.stencilFail,
          materialsStencilZFail: coneLambert.material.stencilZFail,
          materialsStencilZPass: coneLambert.material.stencilZPass,
          materialsOpacity: coneLambert.material.opacity,
          materialsPolygonOffset: coneLambert.material.polygonOffset,
          materialsPolygonOffsetFactor: coneLambert.material.polygonOffsetFactor,
          materialsPolygonOffsetUnits: coneLambert.material.polygonOffsetUnits,
          materialsPrecision: coneLambert.material.precision,
          materialsPremultipliedAlpha: coneLambert.material.premultipliedAlpha,
          materialsDithering: coneLambert.material.dithering,
          materialsShadowSide: coneLambert.material.shadowSide,
          materialsSide: coneLambert.material.side,
          materialsToneMapped: coneLambert.material.toneMapped,
          materialsTransparent: coneLambert.material.transparent,
          materialsVertexColors: coneLambert.material.vertexColors,

          // Properties common betweeen MeshLambertMaterial, MeshPhongMaterial, and MeshPhysicalMaterial
          materialsAlphaMap: coneLambert.material.alphaMap,
          materialsAoMap: coneLambert.material.aoMap,
          materialsAoMapIntensity: coneLambert.material.aoMapIntensity,
          materialsBumpMap: coneLambert.material.bumpMap,
          materialsBumpScale: coneLambert.material.bumpScale,
          materialsColor: coneLambert.material.color,
          materialsCombine: coneLambert.material.combine,
          materialsDisplacementMap: coneLambert.material.displacementMap,
          materialsDisplacementScale: coneLambert.material.displacementScale,
          materialsDisplacementBias: coneLambert.material.displacementBias,
          materialsEmissive: coneLambert.material.emissive,
          materialsEmissiveMap: coneLambert.material.emissiveMap,
          materialsEmissiveIntensity: coneLambert.material.emissiveIntensity,
          materialsEnvMap: coneLambert.material.envMap,
          materialsFlatShading: coneLambert.material.flatShading,
          materialsFog: coneLambert.material.fog,
          materialsLightMap: coneLambert.material.lightMap,
          materialsLightMapIntensity: coneLambert.material.lightMapIntensity,
          materialsMap: coneLambert.material.map,
          materialsNormalMap: coneLambert.material.normalMap,
          materialsNormalMapType: coneLambert.material.normalMapType,
          materialsNormalScaleX: coneLambert.material.normalScale.x,
          materialsNormalScaleY: coneLambert.material.normalScale.y,
          materialsWireframe: coneLambert.material.wireframe,
          materialsWireframeLinecap: coneLambert.material.wireframeLinecap,
          materialsWireframeLinejoin: coneLambert.material.wireframeLinejoin,
          materialsWireframeLinewidth: coneLambert.material.wireframeLinewidth,

          // Lambert material setting
          lambertCombine: coneLambert.material.combine,
          lambertReflectivity: coneLambert.material.reflectivity,
          lambertRefractionRatio: coneLambert.material.refractionRatio,
          lambertSpecularMap: coneLambert.material.specularMap,

          // Phong
          phongCombine: cylinderPhong.material.combine,
          phongReflectivity: cylinderPhong.material.reflectivity,
          phongRefractionRatio: cylinderPhong.material.refractionRatio,
          phongShininess: cylinderPhong.material.shininess,
          phongSpecular: cylinderPhong.material.specular,
          phongSpecularMap: cylinderPhong.material.specularMap,

          // Physical
          physicalEnvMapIntensity: spherePhysical.material.envMapIntensity,
          physicalMetalness: spherePhysical.material.metalness,
          physicalMetalnessMap: spherePhysical.material.metalnessMap,
          physicalRoughness: spherePhysical.material.roughness,
          physicalRoughnessMap: spherePhysical.material.roughnessMap,
          physicalAttenuationColor: spherePhysical.material.attenuationColor,
          physicalAttenuationDistance: spherePhysical.material.attenuationDistance,
          physicalClearcoat: spherePhysical.material.clearcoat,
          physicalClearcoatMap: spherePhysical.material.clearcoatMap,
          physicalClearcoatNormalMap: spherePhysical.material.clearcoatNormalMap,
          physicalClearcoatNormalScaleX: spherePhysical.material.clearcoatNormalScale.x,
          physicalClearcoatNormalScaleY: spherePhysical.material.clearcoatNormalScale.y,
          physicalClearcoatRoughness: spherePhysical.material.clearcoatRoughness,
          physicalClearcoatRoughnessMap: spherePhysical.material.clearcoatRoughnessMap,
          physicalIor: spherePhysical.material.ior,
          physicalReflectivity: spherePhysical.material.reflectivity,
          physicalSheen: spherePhysical.material.sheen,
          physicalSheenRoughness: spherePhysical.material.sheenRoughness,
          physicalSheenRoughnessMap: spherePhysical.material.sheenRoughnessMap,
          physicalSheenColor: spherePhysical.material.sheenColor,
          physicalSheenColorMap: spherePhysical.material.sheenColorMap,
          physicalSpecularIntensity: spherePhysical.material.specularIntensity,
          physicalSpecularIntensityMap: spherePhysical.material.specularIntensityMap,
          physicalSpecularColor: spherePhysical.material.specularColor,
          physicalSpecularColorMap: spherePhysical.material.specularColorMap,
          physicalThickness: spherePhysical.material.thickness,
          physicalThicknessMap: spherePhysical.material.thicknessMap,
          physicalTransmission: spherePhysical.material.transmission,
          physicalTransmissionMap: spherePhysical.material.transmissionMap,
        };

        // Top-level folder for structure related folders
        const folderStructure = gui.addFolder("Structure");
        folderStructure.close();

        // Screen lowerer settings
        const folderScreenLowerer = folderStructure.addFolder("Screen Lowerers");
        folderScreenLowerer
          .add(settings, "enableFrontScreenLowerer")
          .name("Enable front")
          .onChange((toggle) => {
            frontScreenLowerer.visible = toggle;
          });
        folderScreenLowerer
          .add(settings, "enableLeftScreenLowerer")
          .name("Enable left")
          .onChange((toggle) => {
            leftScreenLowerer.visible = toggle;
          });
        folderScreenLowerer
          .add(settings, "enableRightScreenLowerer")
          .name("Enable right")
          .onChange((toggle) => {
            rightScreenLowerer.visible = toggle;
          });
        folderScreenLowerer
          .add(settings, "enableBackScreenLowerer")
          .name("Enable back")
          .onChange((toggle) => {
            backScreenLowerer.visible = toggle;
          });

        // Panel settings
        const folderPanels = folderStructure.addFolder("Panels");
        folderPanels
          .addColor(settings, "frontPanelColor")
          .name("Front")
          .onChange((color) => {
            frontPanel.material.color.set(color);
            frontTopPanel.material.color.set(color);
          });
        folderPanels
          .addColor(settings, "leftPanelColor")
          .name("Left")
          .onChange((color) => {
            leftPanel.material.color.set(color);
            leftTopPanel.material.color.set(color);
          });
        folderPanels
          .addColor(settings, "rightPanelColor")
          .name("Right")
          .onChange((color) => {
            rightPanel.material.color.set(color);
            rightTopPanel.material.color.set(color);
          });
        folderPanels
          .addColor(settings, "backPanelColor")
          .name("Back")
          .onChange((color) => {
            backPanel.material.color.set(color);
            backTopPanel.material.color.set(color);
          });
        folderPanels
          .addColor(settings, "roofPanel")
          .name("Roof")
          .onChange((color) => {
            roofPanel.material.color.set(color);
          });

        // Lights folders
        const folderLights = gui.addFolder("Lights");
        folderLights.close();
        const folderDirectionalLight = folderLights.addFolder("Directional Light");
        const folderPointLight = folderLights.addFolder("Point Light");
        const folderSpotLight = folderLights.addFolder("Spot Light");
        const folderHemisphereLight = folderLights.addFolder("Hemisphere Light");

        // Helper object to add common light settings
        // TODO: add ambient light
        const lights = [
          {
            folder: folderDirectionalLight,
            ref: directionalLight,
            prefix: "directionalLight",
          },
          {
            folder: folderPointLight,
            ref: pointLight,
            prefix: "pointLight",
          },
          {
            folder: folderSpotLight,
            ref: spotLight,
            prefix: "spotLight",
          },
          {
            folder: folderHemisphereLight,
            ref: hemisphereLight,
            prefix: "hemisphereLight",
          },
        ];

        function addCommonLightSettings(light) {
          // Add light settings to the gui
          const folder = light["folder"];
          const ref = light["ref"];
          const prefix = light["prefix"];
          folder
            .add(settings, prefix + "Enable")
            .name("Enable")
            .onChange((toggle) => {
              ref.visible = toggle;
            });
          folder
            .add(settings, prefix + "Intensity")
            .min(0)
            .max(1)
            .name("Intensity")
            .onChange((intensity) => {
              ref.intensity = intensity;
            });
          folder
            .addColor(settings, prefix + "Color")
            .name("Color")
            .onChange((color) => {
              ref.color = color;
            });
        }

        // Add common settings for each light
        lights.forEach((light) => {
          addCommonLightSettings(light);
        });

        // Add other directional light settings
        folderDirectionalLight
          .add(settings, "directionalLightCastShadow")
          .name("Cast shadows")
          .onChange((toggle) => {
            directionalLight.castShadow = toggle;
          });
        folderDirectionalLight
          .add(settings, "directionalLightTarget", {
            Scene: scene,
            Table: table,
            Cone: cone,
            Sphere: sphere,
            Cylinder: cylinder,
          })
          .name("Target")
          .onChange((tgt) => {
            directionalLight.target = tgt;
          });

        // Add other point light settings
        folderPointLight
          .add(settings, "pointLightCastShadow")
          .name("Cast shadows")
          .onChange((toggle) => {
            pointLight.castShadow = toggle;
          });
        // TODO: In context of physically-correct rendering the default value (2) should not be changed.
        folderPointLight
          .add(settings, "pointLightDecay")
          .min(0)
          .max(100)
          .name("Decay")
          .onChange((value) => {
            pointLight.decay = value;
          });
        folderPointLight
          .add(settings, "pointLightDistance")
          .min(0)
          .max(100)
          .name("Distance")
          .onChange((value) => {
            pointLight.distance = value;
          });
        folderPointLight
          .add(settings, "pointLightPower")
          .min(0)
          .max(100)
          .name("Power")
          .onChange((value) => {
            pointLight.power = value;
          });

        // TODO: NEXT STEPS HERE!

        // Add other spot light settings
        folderSpotLight
          .add(settings, "spotLightAngle")
          .min(0)
          .max(180)
          .name("Angle (degrees)")
          .onChange((value) => {
            spotLight.angle = value * (Math.PI / 180);
          });
        folderSpotLight
          .add(settings, "spotLightCastShadow")
          .name("Cast shadow")
          .onChange((toggle) => {
            spotLight.castShadow = toggle;
          });
        folderSpotLight
          .add(settings, "spotLightDecay")
          .min(0)
          .max(100)
          .name("Decay")
          .onChange((value) => {
            spotLight.decay = value;
          });
        folderSpotLight
          .add(settings, "spotLightDistance")
          .min(0)
          .max(100)
          .name("Distance")
          .onChange((value) => {
            spotLight.distance = value;
          });
        folderSpotLight
          .add(settings, "spotLightPenumbra")
          .min(0)
          .max(1)
          .name("Penumbra")
          .onChange((value) => {
            spotLight.penumbra = value;
          });
        folderSpotLight
          .add(settings, "spotLightPower")
          .min(0)
          .max(100)
          .name("Power")
          .onChange((value) => {
            spotLight.power = value;
          });
        folderSpotLight
          .add(settings, "spotLightTarget", {
            Scene: scene,
            Table: table,
            Cone: cone,
            Sphere: sphere,
            Cylinder: cylinder,
          })
          .name("Target")
          .onChange((tgt) => {
            spotLight.target = tgt;
          });

        // Add other hemisphere light settings
        folderHemisphereLight
          .addColor(settings, "hemisphereLightGroundColor")
          .name("Ground color")
          .onChange((color) => {
            hemisphereLight.groundColor = color;
          });

        // TODO: add other ambient light settings

        /* --- MATERIALS --- */
        const folderMaterial = gui.addFolder("Materials");
        folderMaterial.close();
        const folderMaterialCommon = folderMaterial.addFolder("Common settings");
        folderMaterialCommon.close();
        const folderMaterialLambert = folderMaterial.addFolder("Lambertian");
        folderMaterialLambert.close();
        const folderMaterialPhong = folderMaterial.addFolder("Phong");
        folderMaterialPhong.close();
        const folderMaterialPhysical = folderMaterial.addFolder("Physical");
        folderMaterialPhysical.close();

        function addCommonMaterialSettings(folder) {
          // Add materials settings to the gui
          const prefix = "materials";

          folder
            .add(settings, prefix + "AlphaTest")
            .name("Alpha test")
            .onChange((value) => {
              coneLambert.material.alphaTest = value;
              cylinderPhong.material.alphaTest = value;
              spherePhysical.material.alphaTest = value;
            });

          folder
            .add(settings, prefix + "AlphaToCoverage")
            .name("Alpha to coverage")
            .onChange((value) => {
              coneLambert.material.alphaToCoverage = value;
              cylinderPhong.material.alphaToCoverage = value;
              spherePhysical.material.alphaToCoverage = value;
            });

          folder
            .add(settings, prefix + "Blending", {
              None: THREE.NoBlending,
              Normal: THREE.NormalBlending,
              Additive: THREE.AdditiveBlending,
              Subtractive: THREE.SubtractiveBlending,
              Multiply: THREE.MultiplyBlending,
              Custom: THREE.CustomBlending,
            })
            .name("Blending")
            .onChange((value) => {
              coneLambert.material.blending = value;
              cylinderPhong.material.blending = value;
              spherePhysical.material.blending = value;
            });

          folder
            .add(settings, prefix + "BlendDst", {
              "One factor": THREE.OneFactor,
              "Zero factor": THREE.ZeroFactor,
              "Src color factor": THREE.SrcColorFactor,
              "One minus src color factor": THREE.OneMinusSrcColorFactor,
              "Src alpha factor": THREE.SrcAlphaFactor,
              "One minus src alpha factor": THREE.OneMinusSrcAlphaFactor,
              "Dst alpha factor": THREE.DstAlphaFactor,
              "One minus dst alpha factor": THREE.OneMinusDstAlphaFactor,
              "Dst color factor": THREE.DstColorFactor,
              "One minus dst color factor": THREE.OneMinusDstColorFactor,
            })
            .name("Blending destination")
            .onChange((value) => {
              coneLambert.material.blendDst = value;
              cylinderPhong.material.blendDst = value;
              spherePhysical.material.blendDst = value;
            });

          folder
            .add(settings, prefix + "BlendDstAlpha")
            .name("Blending destination transparency")
            .onChange((value) => {
              coneLambert.material.blendDstAlpha = value;
              cylinderPhong.material.blendDstAlpha = value;
              spherePhysical.material.blendDstAlpha = value;
            });

          folder
            .add(settings, prefix + "BlendEquation", {
              "One factor": THREE.AddEquation,
              "Zero factor": THREE.SubtractEquation,
              "Src color factor": THREE.ReverseSubtractEquation,
              "One minus src color factor": THREE.MinEquation,
              "Src alpha factor": THREE.MaxEquation,
            })
            .name("Blending equation")
            .onChange((value) => {
              coneLambert.material.blendEquation = value;
              cylinderPhong.material.blendEquation = value;
              spherePhysical.material.blendEquation = value;
            });

          folder
            .add(settings, prefix + "BlendEquationAlpha")
            .min(0)
            .max(1)
            .name("Blending equation transparency")
            .onChange((value) => {
              coneLambert.material.blendEquationAlpha = value;
              cylinderPhong.material.blendEquationAlpha = value;
              spherePhysical.material.blendEquationAlpha = value;
            });

          folder
            .add(settings, prefix + "BlendSrc", {
              "One factor": THREE.OneFactor,
              "Zero factor": THREE.ZeroFactor,
              "Src color factor": THREE.SrcColorFactor,
              "One minus src color factor": THREE.OneMinusSrcColorFactor,
              "Src alpha factor": THREE.SrcAlphaFactor,
              "One minus src alpha factor": THREE.OneMinusSrcAlphaFactor,
              "Dst alpha factor": THREE.DstAlphaFactor,
              "One minus dst alpha factor": THREE.OneMinusDstAlphaFactor,
              "Dst color factor": THREE.DstColorFactor,
              "One minus dst color factor": THREE.OneMinusDstColorFactor,
              "Src alpha saturate factor": THREE.SrcAlphaSaturateFactor,
            })
            .name("Blending source")
            .onChange((value) => {
              coneLambert.material.blendSrc = value;
              cylinderPhong.material.blendSrc = value;
              spherePhysical.material.blendSrc = value;
            });

          folder
            .add(settings, prefix + "BlendSrcAlpha")
            .min(0)
            .max(1)
            .name("Blending source transparency")
            .onChange((value) => {
              coneLambert.material.blendSrcAlpha = value;
              cylinderPhong.material.blendSrcAlpha = value;
              spherePhysical.material.blendSrcAlpha = value;
            });

          folder
            .add(settings, prefix + "ClipIntersection")
            .name("Clip intersection")
            .onChange((toggle) => {
              coneLambert.material.clipIntersection = toggle;
              cylinderPhong.material.clipIntersection = toggle;
              spherePhysical.material.clipIntersection = toggle;
            });

          folder
            .add(settings, prefix + "ClipShadows")
            .name("Clip shadows")
            .onChange((toggle) => {
              coneLambert.material.clipShadows = toggle;
              cylinderPhong.material.clipShadows = toggle;
              spherePhysical.material.clipShadows = toggle;
            });

          folder
            .add(settings, prefix + "ColorWrite")
            .name("Color write")
            .onChange((toggle) => {
              coneLambert.material.colorWrite = toggle;
              cylinderPhong.material.colorWrite = toggle;
              spherePhysical.material.colorWrite = toggle;
            });

          folder
            .add(settings, prefix + "DepthFunc", {
              Never: THREE.NeverDepth,
              Always: THREE.AlwaysDepth,
              Equal: THREE.EqualDepth,
              Less: THREE.LessDepth,
              "Less equal": THREE.LessEqualDepth,
              "Greater equal": THREE.GreaterEqualDepth,
              Greater: THREE.GreaterDepth,
              "Not equal": THREE.NotEqualDepth,
            })
            .name("Depth function")
            .onChange((value) => {
              coneLambert.material.depthFunc = value;
              cylinderPhong.material.depthFunc = value;
              spherePhysical.material.depthFunc = value;
            });

          folder
            .add(settings, prefix + "DepthTest")
            .name("Enable depth test")
            .onChange((value) => {
              coneLambert.material.depthTest = value;
              cylinderPhong.material.depthTest = value;
              spherePhysical.material.depthTest = value;
            });

          folder
            .add(settings, prefix + "DepthWrite")
            .name("Enable depth write")
            .onChange((value) => {
              coneLambert.material.depthWrite = value;
              cylinderPhong.material.depthWrite = value;
              spherePhysical.material.depthWrite = value;
            });

          folder
            .add(settings, prefix + "StencilWrite")
            .name("Enable stencil write")
            .onChange((value) => {
              coneLambert.material.stencilWrite = value;
              cylinderPhong.material.stencilWrite = value;
              spherePhysical.material.stencilWrite = value;
            });

          folder
            .add(settings, prefix + "StencilWriteMask")
            .name("Stencil write mask")
            .onChange((value) => {
              coneLambert.material.stencilWriteMast = value;
              cylinderPhong.material.stencilWriteMast = value;
              spherePhysical.material.stencilWriteMast = value;
            });

          folder
            .add(settings, prefix + "StencilFunc", {
              Never: THREE.NeverStencilFunc,
              Less: THREE.LessStencilFunc,
              Equal: THREE.EqualStencilFunc,
              "Less equal": THREE.LessEqualStencilFunc,
              "Greater equal": THREE.GreaterStencilFunc,
              "Not equal": THREE.NotEqualStencilFunc,
              "Greater equal": THREE.GreaterEqualStencilFunc,
              Always: THREE.AlwaysStencilFunc,
            })
            .name("Depth function")
            .onChange((value) => {
              coneLambert.material.stencilFunc = value;
              cylinderPhong.material.stencilFunc = value;
              spherePhysical.material.stencilFunc = value;
            });

          folder
            .add(settings, prefix + "StencilRef")
            .name("Stencil ref")
            .onChange((value) => {
              coneLambert.material.stencilRef = value;
              cylinderPhong.material.stencilRef = value;
              spherePhysical.material.stencilRef = value;
            });

          folder
            .add(settings, prefix + "StencilFuncMask")
            .name("Stencil function mask")
            .onChange((value) => {
              coneLambert.material.stencilFuncMask = value;
              cylinderPhong.material.stencilFuncMask = value;
              spherePhysical.material.stencilFuncMask = value;
            });

          folder
            .add(settings, prefix + "StencilFail", {
              Zero: THREE.ZeroStencilOp,
              Keep: THREE.KeepStencilOp,
              Replace: THREE.ReplaceStencilOp,
              Increment: THREE.IncrementStencilOp,
              Decrement: THREE.DecrementStencilOp,
              "Increment wrap": THREE.IncrementWrapStencilOp,
              "Decrement wrap": THREE.DecrementWrapStencilOp,
              Invert: THREE.InvertStencilOp,
            })
            .name("Stencil fail operation")
            .onChange((value) => {
              coneLambert.material.stencilFail = value;
              cylinderPhong.material.stencilFail = value;
              spherePhysical.material.stencilFail = value;
            });

          folder
            .add(settings, prefix + "StencilZFail", {
              Zero: THREE.ZeroStencilOp,
              Keep: THREE.KeepStencilOp,
              Replace: THREE.ReplaceStencilOp,
              Increment: THREE.IncrementStencilOp,
              Decrement: THREE.DecrementStencilOp,
              "Increment wrap": THREE.IncrementWrapStencilOp,
              "Decrement wrap": THREE.DecrementWrapStencilOp,
              Invert: THREE.InvertStencilOp,
            })
            .name("Stencil Z fail operation")
            .onChange((value) => {
              coneLambert.material.stencilZFail = value;
              cylinderPhong.material.stencilZFail = value;
              spherePhysical.material.stencilZFail = value;
            });

          folder
            .add(settings, prefix + "StencilZPass", {
              Zero: THREE.ZeroStencilOp,
              Keep: THREE.KeepStencilOp,
              Replace: THREE.ReplaceStencilOp,
              Increment: THREE.IncrementStencilOp,
              Decrement: THREE.DecrementStencilOp,
              "Increment wrap": THREE.IncrementWrapStencilOp,
              "Decrement wrap": THREE.DecrementWrapStencilOp,
              Invert: THREE.InvertStencilOp,
            })
            .name("Stencil Z pass operation")
            .onChange((value) => {
              coneLambert.material.stencilZPass = value;
              cylinderPhong.material.stencilZPass = value;
              spherePhysical.material.stencilZPass = value;
            });

          folder
            .add(settings, prefix + "Transparent")
            .name("Enable transparency")
            .onChange((value) => {
              coneLambert.material.transparent = value;
              cylinderPhong.material.transparent = value;
              spherePhysical.material.transparent = value;
            });

          folder
            .add(settings, prefix + "Opacity")
            .min(0)
            .max(1)
            .name("Opacity")
            .onChange((value) => {
              coneLambert.material.opacity = value;
              cylinderPhong.material.opacity = value;
              spherePhysical.material.opacity = value;
            });

          folder
            .add(settings, prefix + "PolygonOffset")
            .name("Polygon Offset")
            .onChange((value) => {
              coneLambert.material.polygonOffset = value;
              cylinderPhong.material.polygonOffset = value;
              spherePhysical.material.polygonOffset = value;
            });

          folder
            .add(settings, prefix + "PolygonOffsetFactor")
            .name("Polygon offset factor")
            .onChange((value) => {
              coneLambert.material.polygonOffsetFactor = value;
              cylinderPhong.material.polygonOffsetFactor = value;
              spherePhysical.material.polygonOffsetFactor = value;
            });

          folder
            .add(settings, prefix + "PolygonOffsetUnits")
            .name("Polygon offset units")
            .onChange((value) => {
              coneLambert.material.polygonOffsetUnits = value;
              cylinderPhong.material.polygonOffsetUnits = value;
              spherePhysical.material.polygonOffsetUnits = value;
            });

          folder
            .add(settings, prefix + "Precision", {
              High: "highp",
              Medium: "mediump",
              Low: "lowp",
              Null: null,
            })
            .name("Precision")
            .onChange((value) => {
              coneLambert.material.precision = value;
              cylinderPhong.material.precision = value;
              spherePhysical.material.precision = value;
            });

          folder
            .add(settings, prefix + "PremultipliedAlpha")
            .name("Premultiplied alpha")
            .onChange((value) => {
              coneLambert.material.premultipliedAlpha = value;
              cylinderPhong.material.premultipliedAlpha = value;
              spherePhysical.material.premultipliedAlpha = value;
            });

          folder
            .add(settings, prefix + "Dithering")
            .name("Dithering")
            .onChange((value) => {
              coneLambert.material.dithering = value;
              cylinderPhong.material.dithering = value;
              spherePhysical.material.dithering = value;
            });

          folder
            .add(settings, prefix + "ShadowSide", {
              Front: THREE.FrontSide,
              Back: THREE.BackSide,
              Double: THREE.DoubleSide,
              Null: null,
            })
            .name("Shadow side")
            .onChange((value) => {
              coneLambert.material.shadowSide = value;
              cylinderPhong.material.shadowSide = value;
              spherePhysical.material.shadowSide = value;
            });

          folder
            .add(settings, prefix + "Side", {
              Front: THREE.FrontSide,
              Back: THREE.BackSide,
              Double: THREE.DoubleSide,
            })
            .name("Side")
            .onChange((value) => {
              coneLambert.material.side = value;
              cylinderPhong.material.side = value;
              spherePhysical.material.side = value;
            });

          folder
            .add(settings, prefix + "ToneMapped")
            .name("Tone mapped")
            .onChange((value) => {
              coneLambert.material.toneMapped = value;
              cylinderPhong.material.toneMapped = value;
              spherePhysical.material.toneMapped = value;
            });

          folder
            .add(settings, prefix + "VertexColors")
            .name("Enable vertex colors")
            .onChange((value) => {
              coneLambert.material.vertexColors = value;
              cylinderPhong.material.vertexColors = value;
              spherePhysical.material.vertexColors = value;
            });

          folder
            .add(settings, prefix + "AlphaMap", { Null: null, "Grenouille-gray": exampleGrayTexture })
            .name("Alpha map")
            .onChange((value) => {
              coneLambert.material.alphaMap = value;
              cylinderPhong.material.alphaMap = value;
              spherePhysical.material.alphaMap = value;
            });

          folder
            .add(settings, prefix + "AoMap", {
              Null: null,
              Grenouille: exampleTexture,
              "Grenouille-gray": exampleGrayTexture,
            })
            .name("Ambient occlusion map")
            .onChange((value) => {
              coneLambert.material.aoMap = value;
              cylinderPhong.material.aoMap = value;
              spherePhysical.material.aoMap = value;
            });

          folder
            .add(settings, prefix + "AoMapIntensity")
            .min(0)
            .name("Ambient occlusion intensity")
            .onChange((value) => {
              coneLambert.material.aoMapIntensity = value;
              cylinderPhong.material.aoMapIntensity = value;
              spherePhysical.material.aoMapIntensity = value;
            });

          folder
            .add(settings, prefix + "BumpMap", {
              Null: null,
              Grenouille: exampleTexture,
              "Grenouille-gray": exampleGrayTexture,
            })
            .name("Bump map")
            .onChange((value) => {
              coneLambert.material.bumpMap = value;
              cylinderPhong.material.bumpMap = value;
              spherePhysical.material.bumpMap = value;
            });

          folder
            .add(settings, prefix + "BumpScale")
            .min(0)
            .name("Bump map scale")
            .onChange((value) => {
              coneLambert.material.bumpScale = value;
              cylinderPhong.material.bumpScale = value;
              spherePhysical.material.bumpScale = value;
            });

          folder
            .addColor(settings, prefix + "Color")
            .name("Color")
            .onChange((value) => {
              coneLambert.material.color = value;
              cylinderPhong.material.color = value;
              spherePhysical.material.color = value;
            });

          folder
            .add(settings, prefix + "DisplacementMap", {
              Null: null,
              Grenouille: exampleTexture,
              "Grenouille-gray": exampleGrayTexture,
            })
            .name("Displacement map")
            .onChange((value) => {
              coneLambert.material.displacementMap = value;
              cylinderPhong.material.displacementMap = value;
              spherePhysical.material.displacementMap = value;
            });

          folder
            .add(settings, prefix + "DisplacementScale")
            .name("Displacement scale")
            .onChange((value) => {
              coneLambert.material.displacementScale = value;
              cylinderPhong.material.displacementScale = value;
              spherePhysical.material.displacementScale = value;
            });

          folder
            .add(settings, prefix + "DisplacementBias")
            .name("Displacement bias")
            .onChange((value) => {
              coneLambert.material.displacementBias = value;
              cylinderPhong.material.displacementBias = value;
              spherePhysical.material.displacementBias = value;
            });

          folder
            .addColor(settings, prefix + "Emissive")
            .name("Emissive (light) color")
            .onChange((value) => {
              coneLambert.material.emissive = value;
              cylinderPhong.material.emissive = value;
              spherePhysical.material.emissive = value;
            });

          folder
            .add(settings, prefix + "EmissiveMap", {
              Null: null,
              Grenouille: exampleTexture,
              "Grenouille-gray": exampleGrayTexture,
            })
            .name("Emissive (glow) map")
            .onChange((value) => {
              coneLambert.material.emissiveMap = value;
              cylinderPhong.material.emissiveMap = value;
              spherePhysical.material.emissiveMap = value;
            });

          folder
            .add(settings, prefix + "EmissiveIntensity")
            .name("Emissive intensity")
            .onChange((value) => {
              coneLambert.material.emissiveIntensity = value;
              cylinderPhong.material.emissiveIntensity = value;
              spherePhysical.material.emissiveIntensity = value;
            });

          folder
            .add(settings, prefix + "EnvMap", {
              Null: null,
              Grenouille: exampleTexture,
              "Grenouille-gray": exampleGrayTexture,
            })
            .name("Environment map")
            .onChange((value) => {
              coneLambert.material.envMap = value;
              cylinderPhong.material.envMap = value;
              spherePhysical.material.envMap = value;
            });

          folder
            .add(settings, prefix + "FlatShading")
            .name("Enable flat shading")
            .onChange((value) => {
              coneLambert.material.flatShading = value;
              cylinderPhong.material.flatShading = value;
              spherePhysical.material.flatShading = value;
            });

          folder
            .add(settings, prefix + "Fog")
            .name("Affected by fog")
            .onChange((value) => {
              coneLambert.material.fog = value;
              cylinderPhong.material.fog = value;
              spherePhysical.material.fog = value;
            });

          folder
            .add(settings, prefix + "LightMap", {
              Null: null,
              Grenouille: exampleTexture,
              "Grenouille-gray": exampleGrayTexture,
            })
            .name("Light map")
            .onChange((value) => {
              coneLambert.material.lightMap = value;
              cylinderPhong.material.lightMap = value;
              spherePhysical.material.lightMap = value;
            });

          folder
            .add(settings, prefix + "LightMapIntensity")
            .name("Light map intensity")
            .onChange((value) => {
              coneLambert.material.lightMapIntensity = value;
              cylinderPhong.material.lightMapIntensity = value;
              spherePhysical.material.lightMapIntensity = value;
            });

          folder
            .add(settings, prefix + "Map", {
              Null: null,
              Grenouille: exampleTexture,
              "Grenouille-gray": exampleGrayTexture,
            })
            .name("Color map")
            .onChange((value) => {
              coneLambert.material.map = value;
              cylinderPhong.material.map = value;
              spherePhysical.material.map = value;
            });

          folder
            .add(settings, prefix + "NormalMap", {
              Null: null,
              Grenouille: exampleTexture,
              "Grenouille-gray": exampleGrayTexture,
            })
            .name("Normal map")
            .onChange((value) => {
              coneLambert.material.normalMap = value;
              cylinderPhong.material.normalMap = value;
              spherePhysical.material.normalMap = value;
            });

          folder
            .add(settings, prefix + "NormalMapType", {
              "Tangent space": THREE.TangentSpaceNormalMap,
              "Object space": THREE.ObjectSpaceNormalMap,
            })
            .name("Normal map type")
            .onChange((value) => {
              coneLambert.material.normalMapType = value;
              cylinderPhong.material.normalMapType = value;
              spherePhysical.material.normalMapType = value;
            });

          folder
            .add(settings, prefix + "NormalScaleX")
            .name("Normal scale X")
            .onChange((value) => {
              coneLambert.material.normalScale.x = value;
              cylinderPhong.material.normalScale.x = value;
              spherePhysical.material.normalScale.x = value;
            });

          folder
            .add(settings, prefix + "NormalScaleY")
            .name("Normal scale Y")
            .onChange((value) => {
              coneLambert.material.normalScale.y = value;
              cylinderPhong.material.normalScale.y = value;
              spherePhysical.material.normalScale.y = value;
            });

          folder
            .add(settings, prefix + "Wireframe")
            .name("Wireframe")
            .onChange((value) => {
              coneLambert.material.wireframe = value;
              cylinderPhong.material.wireframe = value;
              spherePhysical.material.wireframe = value;
            });

          folder
            .add(settings, prefix + "WireframeLinecap", { Round: "round", Butt: "butt", Square: "square" })
            .name("Wireframe linecap")
            .onChange((value) => {
              coneLambert.material.wireframeLinecap = value;
              cylinderPhong.material.wireframeLinecap = value;
              spherePhysical.material.wireframeLinecap = value;
            });

          folder
            .add(settings, prefix + "WireframeLinejoin", { Round: "round", Bevel: "bevel", Miter: "miter" })
            .name("Wireframe linejoin")
            .onChange((value) => {
              coneLambert.material.wireframeLinejoin = value;
              cylinderPhong.material.wireframeLinejoin = value;
              spherePhysical.material.wireframeLinejoin = value;
            });
        }

        addCommonMaterialSettings(folderMaterialCommon);

        /* --- LAMBERT --- */
        folderMaterialLambert
          .add(settings, "lambertCombine", {
            Multiply: THREE.MultiplyOperation,
            Mix: THREE.MixOperation,
            Add: THREE.AddOperation,
          })
          .name("Combine")
          .onChange((value) => {
            coneLambert.material.combine = value;
          });

        folderMaterialLambert
          .add(settings, "lambertReflectivity")
          .name("Reflectivity")
          .onChange((value) => {
            coneLambert.material.reflectivity = value;
          });

        folderMaterialLambert
          .add(settings, "lambertRefractionRatio")
          .name("Refraction")
          .onChange((value) => {
            coneLambert.material.refractionRatio = value;
          });

        folderMaterialLambert
          .add(settings, "lambertSpecularMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Specular map")
          .onChange((value) => {
            coneLambert.material.specularMap = value;
          });

        /* --- PHONG --- */
        folderMaterialPhong
          .add(settings, "phongCombine", {
            Multiply: THREE.MultiplyOperation,
            Mix: THREE.MixOperation,
            Add: THREE.AddOperation,
          })
          .name("Combine")
          .onChange((value) => {
            cylinderPhong.material.combine = value;
          });

        folderMaterialPhong
          .add(settings, "phongReflectivity")
          .name("Reflectivity")
          .onChange((value) => {
            cylinderPhong.material.reflectivity = value;
          });

        folderMaterialPhong
          .add(settings, "phongRefractionRatio")
          .name("Refraction")
          .onChange((value) => {
            cylinderPhong.material.refractionRatio = value;
          });

        folderMaterialPhong
          .add(settings, "phongShininess")
          .name("Shininess")
          .onChange((value) => {
            cylinderPhong.material.shininess = value;
          });

        folderMaterialPhong
          .addColor(settings, "phongSpecular")
          .name("Specular color")
          .onChange((value) => {
            cylinderPhong.material.specularColor = value;
          });

        folderMaterialPhong
          .add(settings, "phongSpecularMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Specular map")
          .onChange((value) => {
            cylinderPhong.material.specularMap = value;
          });

        /* --- PHYSICAL --- */
        // MeshStandardMaterial properties
        folderMaterialPhysical
          .add(settings, "physicalEnvMapIntensity")
          .name("Environment map intensity")
          .onChange((value) => {
            spherePhysical.material.envMapIntensity = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalMetalness")
          .name("Metalness")
          .onChange((value) => {
            spherePhysical.material.metalness = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalMetalnessMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Metalness map")
          .onChange((value) => {
            spherePhysical.material.metalnessMap = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalRoughness")
          .name("Roughness")
          .onChange((value) => {
            spherePhysical.material.roughness = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalRoughnessMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Roughness map")
          .onChange((value) => {
            spherePhysical.material.roughnessMap = value;
          });

        // Physical material properties
        folderMaterialPhysical
          .addColor(settings, "physicalAttenuationColor")
          .name("Attenuation color")
          .onChange((value) => {
            spherePhysical.material.attenuationColor = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalAttenuationDistance")
          .min(0)
          .name("Attenuation distance")
          .onChange((value) => {
            spherePhysical.material.attenuationDistance = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalClearcoat")
          .min(0)
          .max(1)
          .name("Clear coat layer intensity")
          .onChange((value) => {
            spherePhysical.material.clearcoat = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalClearcoatMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Clearcoat map")
          .onChange((value) => {
            spherePhysical.material.clearcoatMap = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalClearcoatNormalMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Clearcoat normal map")
          .onChange((value) => {
            spherePhysical.material.clearcoatNormalMap = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalClearcoatNormalScaleX")
          .min(0)
          .max(1)
          .name("Clearcoat normal scale X")
          .onChange((value) => {
            spherePhysical.material.clearcoatNormalScale.x = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalClearcoatNormalScaleY")
          .min(0)
          .max(1)
          .name("Clearcoat normal scale y")
          .onChange((value) => {
            spherePhysical.material.clearcoatNormalScale.y = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalClearcoatRoughness")
          .min(0)
          .max(1)
          .name("Clearcoat roughness")
          .onChange((value) => {
            spherePhysical.material.clearcoatRoughness = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalClearcoatRoughnessMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Clearcoat roughness map")
          .onChange((value) => {
            spherePhysical.material.clearcoatRoughnessMap = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalIor")
          .min(1)
          .max(2.333)
          .name("Index of refraction (ior)")
          .onChange((value) => {
            spherePhysical.material.ior = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalReflectivity")
          .min(0)
          .max(1)
          .name("Reflectivity")
          .onChange((value) => {
            spherePhysical.material.reflectivity = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalSheen")
          .min(0)
          .max(1)
          .name("Sheen layer intensity")
          .onChange((value) => {
            spherePhysical.material.sheen = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalSheenRoughness")
          .min(0)
          .max(1)
          .name("Sheen layer roughness")
          .onChange((value) => {
            spherePhysical.material.sheen = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalSheenRoughnessMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Sheen roughness map")
          .onChange((value) => {
            spherePhysical.material.sheenRoughnessMap = value;
          });

        folderMaterialPhysical
          .addColor(settings, "physicalSheenColor")
          .name("Sheen color")
          .onChange((value) => {
            spherePhysical.material.sheenColor = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalSheenColorMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Sheen color map")
          .onChange((value) => {
            spherePhysical.material.sheenColorMap = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalSpecularIntensity")
          .min(0)
          .max(1)
          .name("Specular intensity")
          .onChange((value) => {
            spherePhysical.material.specularIntensity = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalSpecularIntensityMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Specular intensity map")
          .onChange((value) => {
            spherePhysical.material.specularIntensityMap = value;
          });

        folderMaterialPhysical
          .addColor(settings, "physicalSpecularColor")
          .name("Specular color")
          .onChange((value) => {
            spherePhysical.material.specularColor = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalSpecularColorMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Specular color map")
          .onChange((value) => {
            spherePhysical.material.specularColorMap = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalThickness")
          .name("Thickness")
          .onChange((value) => {
            spherePhysical.material.thickness = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalThicknessMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Thickness map")
          .onChange((value) => {
            spherePhysical.material.thicknessMap = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalTransmission")
          .min(0)
          .max(1)
          .name("Transmission")
          .onChange((value) => {
            spherePhysical.material.thickness = value;
          });

        folderMaterialPhysical
          .add(settings, "physicalTransmissionMap", {
            Null: null,
            Grenouille: exampleTexture,
            "Grenouille-gray": exampleGrayTexture,
          })
          .name("Transmission map")
          .onChange((value) => {
            spherePhysical.material.transmissionMap = value;
          });

        // TODO: for VR, place the gui as an object with listeners for sessionStart and sessionEnd so it only shows up in VR
      }

      // Traverse all children nodes of a parent node
      function traverse(node, f) {
        f(node);
        node.children.forEach((nextNode) => {
          traverse(nextNode, f);
        });
      }

      // Enable shadows for object
      function enableShadows(obj) {
        // Warning: very computationally costly
        if (obj.isMesh === true) {
          obj.castShadow = true;
          obj.receiveShadow = true;
        }
      }

      // Enable transparency for object meshes
      function enableTransparency(obj) {
        if (obj.isMesh === true) {
          obj.material.transparent = true;
          obj.material.opacity = 0.5;
        }
      }

      // Setup VR
      function setupVR() {
        // Enable XR
        renderer.xr.enabled = true;

        // Add XR button
        document.body.appendChild(VRButton.createButton(renderer));

        // Controller setup
        const controllerModelFactory = new XRControllerModelFactory();
        const controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);
        const controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);
      }

      /* FROM PREVIOUS EXERCISES */
      // Fix window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Create a cross using a Line. `opacity` defines its opacity
      function createCross(opacity) {
        const material = new THREE.LineBasicMaterial({
          color: 0xffffff,
          opacity: opacity,
          transparent: true,
        });
        const points = [];
        points.push(new THREE.Vector3(1, 0, 0));
        points.push(new THREE.Vector3(-1, 0, 0));
        points.push(new THREE.Vector3(0, 0, 0));
        points.push(new THREE.Vector3(0, 0, 1));
        points.push(new THREE.Vector3(0, 0, -1));
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const cross = new THREE.Line(geometry, material);
        return cross;
      }

      // Create a floor of crosses
      function floorOfCrosses(FADE_START = 100, FADE_END = 200) {
        /*
        `FADE_START`:Minimum distance from center with opacity=1
        `FADE_END`: Distance from center at which opacity=0
        */
        const floor = new THREE.Object3D();
        scene.add(floor);
        floor.position.y = 0.1;
        // Loop through x and z axis from -50 to +50, so that the floor center is at (0,0,0)
        for (let x = -50; x < 50; x++) {
          // x axis
          for (let z = -50; z < 50; z++) {
            // z axis
            const x_pos = x * 10; // Scale up by 10
            const z_pos = z * 10; // Scale up by 10
            // Calculate distance from center to determine cross opacity. This create a fading effect in a round area around the center
            const radius = Math.sqrt(Math.pow(x_pos, 2) + Math.pow(z_pos, 2));
            const FADE_RANGE = FADE_END - FADE_START; // Range of progressive fade
            let crossOpacity;
            if (radius < FADE_START) {
              // Show cross with full opacity when its under the minimum distance
              crossOpacity = 1;
            } else {
              // Progressive opacity reduction the further from the center it is
              const distance = radius - FADE_START; // Distance from start of fade
              crossOpacity = 1 - distance / FADE_RANGE;
            }
            // Create and position the cross
            const cross = createCross(crossOpacity);
            cross.position.x = x_pos;
            cross.position.z = z_pos;
            // Add the cross to the floor as a child
            floor.add(cross);
          }
        }
      }
    </script>
  </body>
</html>
