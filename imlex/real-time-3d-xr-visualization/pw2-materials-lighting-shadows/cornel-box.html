<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Cornel Box</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #c {
        width: 100%;
        height: 100%;
        display: block;
      }

      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display: block;
      }
    </style>
  </head>
  <body>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { VRButton } from "three/addons/webxr/VRButton.js";
      import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";

      /* Main script */
      let camera, globalScene, scene, renderer, controls;

      // Initialize empty scene with cameras and controls
      init();

      // Enable VR
      // setupVR();

      // Create the floor of crosses
      floorOfCrosses(25, 50);

      // Create scene entities
      const cornelBox = createCornelBox();
      const table = createTable();
      const cone = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 32), new THREE.MeshLambertMaterial());
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshPhysicalMaterial());
      const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 32), new THREE.MeshPhongMaterial());

      // Position the scene entities
      cone.position.set(-3, 6, -1);
      sphere.position.set(0, 6.25, 1);
      cylinder.position.set(3, 6, -1);

      // TODO: CHECK MESHSTANDARDMATERIAL IN 3.JS DOCS

      // Add to the scene
      scene.add(cornelBox);
      scene.add(table);
      scene.add(cone);
      scene.add(sphere);
      scene.add(cylinder);

      // Create the GUI
      const gui = createGUI();

      //! DEBUG ONLY: make everything transparent
      // traverse(cornelBox, enableTransparency);

      // Enable shadows
      // traverse(scene.getObjectByName("cornelBox"), enableShadows);

      // Render with setAnimationLoop for XR compatibility
      renderer.setAnimationLoop(function (time) {
        // Update controls
        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

        // Conel box wall animation
        animateCornelBox();

        // Render
        renderer.render(scene, camera);
      });
      /* End of main script */

      // Initialize empty scene with renderer, cameras, lights, and controls
      function init() {
        // Global scene
        scene = new THREE.Scene();

        // Renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Shadows

        // Cameras
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 500);
        camera.position.set(0, 10.5, 14);

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window); // optional
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 0;
        controls.maxDistance = 500;
        controls.target = new THREE.Vector3(0, 10, 0);
        // controls.autoRotate = true;
        controls.autoRotateSpeed = 1;

        // Lights
        {
          const color = 0xffffff;
          const intensity = 1;
          const light = new THREE.DirectionalLight(color, intensity);
          light.position.set(0, 50, 25);
          const helper = new THREE.DirectionalLightHelper(light, 5);
          scene.add(helper);
          scene.add(light);
        }
        {
          const color = 0xffffff;
          const intensity = 1;
          const light = new THREE.DirectionalLight(color, intensity);
          light.position.set(25, 50, -25);
          const helper = new THREE.DirectionalLightHelper(light, 5);
          scene.add(helper);
          scene.add(light);
        }
        {
          const color = 0xffffff;
          const intensity = 1;
          const light = new THREE.DirectionalLight(color, intensity);
          light.position.set(-25, 50, -25);
          const helper = new THREE.DirectionalLightHelper(light, 5);
          scene.add(helper);
          scene.add(light);
        }
        {
          const color = 0xffffff;
          const intensity = 0.2;
          const light = new THREE.AmbientLight(color, intensity);
          scene.add(light);
        }

        // Additional setup
        document.body.appendChild(renderer.domElement);

        // Window resize fix
        window.addEventListener("resize", onWindowResize);

        // Add a simple floor
        const floor = new THREE.Mesh(
          new THREE.BoxGeometry(100, 0.01, 100),
          new THREE.MeshBasicMaterial({ color: "#123456" })
        );
        scene.add(floor);
      }

      // Create a frame piece (metallic lengthy component with fringes)
      function createFramePiece(length) {
        // Create the frame piece group.
        const framePiece = new THREE.Object3D();

        // Create the materials
        const material = new THREE.MeshLambertMaterial({ color: "#AAAFBA" });

        // Create the corners (perspective: top-view).
        const cornerWidth = 0.21875; // Calculated to sum-up with centers and fringes to 1
        const cornerGeometry = new THREE.BoxGeometry(cornerWidth, length, cornerWidth);
        const bLeftCorner = new THREE.Mesh(cornerGeometry, material);
        const bRightCorner = bLeftCorner.clone();
        const tLeftCorner = bLeftCorner.clone();
        const tRightCorner = bLeftCorner.clone();

        // Create the centers
        const centerWidth = cornerWidth * 2;
        const centerGeometry = new THREE.BoxGeometry(cornerWidth * 2, length, 1);
        const frontCenter = new THREE.Mesh(centerGeometry, material);
        const sideCenter = new THREE.Mesh(centerGeometry, material);

        // Create the filler
        const fillerWidth = 1 - cornerWidth;
        const fillerGeometry = new THREE.BoxGeometry(fillerWidth, length - 0.001, fillerWidth);
        const filler = new THREE.Mesh(fillerGeometry, material);

        // Position the corners
        const cornerPos = 0.5 - cornerWidth / 2;
        bLeftCorner.position.set(-cornerPos, length / 2, cornerPos);
        bRightCorner.position.set(cornerPos, length / 2, cornerPos);
        tLeftCorner.position.set(-cornerPos, length / 2, -cornerPos);
        tRightCorner.position.set(cornerPos, length / 2, -cornerPos);

        // Position the centers
        frontCenter.position.y = length / 2;
        sideCenter.position.y = length / 2;
        sideCenter.rotation.y = Math.PI / 2;

        // Position the filler
        filler.position.y = length / 2;

        // Add corners, centers, and filler to the frame piece
        framePiece.add(bLeftCorner);
        framePiece.add(bRightCorner);
        framePiece.add(tLeftCorner);
        framePiece.add(tRightCorner);
        framePiece.add(frontCenter);
        framePiece.add(sideCenter);
        framePiece.add(filler);
        return framePiece;
      }

      // Create a panel (yellow front face, white back face)
      function createPanel() {
        // Create the panel group
        const panel = new THREE.Object3D();

        // Cornel box measurements
        const fringeLength = 0.0625;
        const cornerWidth = 0.21875;

        // Create the front and back faces according to the cornel box measurements
        const panelGeometry = new THREE.BoxGeometry(28, 3, fringeLength / 2);
        const panelMaterials = [
          // Front and Back
          new THREE.MeshLambertMaterial({ color: "#909B21" }),
          new THREE.MeshLambertMaterial({ color: "#ffffff" }),
        ];
        const panelFront = new THREE.Mesh(panelGeometry, panelMaterials[0]);
        const panelBack = new THREE.Mesh(panelGeometry, panelMaterials[1]);

        // Distance the front and back faces
        panelFront.position.z = fringeLength / 2;
        panelBack.position.z = -fringeLength / 2;

        // Add front and back to the panel group
        panel.add(panelFront);
        panel.add(panelBack);

        return panel;
      }

      // Create a screen lowerer
      function createScreenLowerer() {
        // Create the screen lowerer group
        const screenLowerer = new THREE.Object3D();

        // Cornel box measurements
        const fringeLength = 0.0625;
        const cornerWidth = 0.21875;

        // Create the material
        const material = new THREE.MeshLambertMaterial({ color: "#5F6062" });
        const screenMaterial = new THREE.MeshLambertMaterial({ color: "#ffffff" });

        // Create the top frame
        // TODO: gap for side frame and screen, hole detail in the back face
        const tFrameGeometry = new THREE.BoxGeometry(28, 1, 1);
        const tFrame = new THREE.Mesh(tFrameGeometry, material);

        // Create the side frames of the screen lowerer
        // TODO: side frames have a gap for the screen, with the gap filled with brush hair, and a offset detail
        const sFrameGeometry = new THREE.BoxGeometry(0.5, 24, fringeLength + cornerWidth);
        const lFrame = new THREE.Mesh(sFrameGeometry, material);
        const rFrame = new THREE.Mesh(sFrameGeometry, material);

        // Create the screen
        // TODO: bottom part of the screen is bigger than the screen panel + check calculations
        // TODO: frontface of the panel is black / dark gray, back face is white
        const screen = new THREE.Object3D();
        const screenPanelGeometry = new THREE.BoxGeometry(28 - 2 * cornerWidth, 24 - 2 * cornerWidth, fringeLength / 2);
        const screenBottomGeometry = new THREE.BoxGeometry(28 - 2 * cornerWidth, 2 * cornerWidth, fringeLength);
        const screenPanel = new THREE.Mesh(screenPanelGeometry, screenMaterial);
        const screenBottom = new THREE.Mesh(screenBottomGeometry, material);

        // Position the screen parts
        screenBottom.position.y = cornerWidth;
        screenPanel.position.y = 12 + cornerWidth;

        // Add screen parts to the screen group
        screen.add(screenPanel);
        screen.add(screenBottom);

        // Position the frames and the screen
        const innerFringePosition = -(cornerWidth + fringeLength / 2);
        tFrame.position.y = 24.5;
        lFrame.position.set(-14, 12, innerFringePosition);
        rFrame.position.set(14, 12, innerFringePosition);

        // Add parts to the group
        screenLowerer.add(tFrame);
        screenLowerer.add(lFrame);
        screenLowerer.add(rFrame);
        screenLowerer.add(screenBottom);
        screenLowerer.add(screen);

        return screenLowerer;
      }

      // Create one face of the cornel box
      function createCornelFace() {
        // Create the face group
        const face = new THREE.Object3D();

        // Create the frames
        const lFramePiece = createFramePiece(29.5);
        const rFramePiece = createFramePiece(29.5);
        const tFramePiece = createFramePiece(28);
        const bFramePiece = createFramePiece(28);

        // Create the panel
        const panel = createPanel();

        // Create the screen lowerer
        const screenLowerer = createScreenLowerer();

        // Position the frames
        lFramePiece.position.set(-14.5, 0.5, 0);
        rFramePiece.position.set(14.5, 0.5, 0);
        tFramePiece.position.set(-14, 29.5, 0);
        tFramePiece.rotation.z = -Math.PI / 2;
        bFramePiece.position.set(-14, 25.5, 0); // Check the y position calculations
        bFramePiece.rotation.z = -Math.PI / 2;

        // Position the panel on the outermost fringe CHECK CALCULATIONS
        const fringeLength = 0.0625;
        const cornerWidth = 0.21875;
        panel.position.set(0, 27.5, cornerWidth + fringeLength / 2);

        // Add components to the face
        face.add(lFramePiece);
        face.add(rFramePiece);
        face.add(tFramePiece);
        face.add(bFramePiece);
        face.add(panel);
        face.add(screenLowerer);

        return face;
      }

      // Create the roof lamp
      // TODO: make the lamp model
      function createLamp() {
        // Create the lamp group
        const lamp = new THREE.Object3D();

        // Create a placeholder cube for the lamp
        const lampMaterial = new THREE.MeshLambertMaterial({ color: "#ffffff" });
        const lampGeometry = new THREE.BoxGeometry(1, 1, 1);
        const lampCube = new THREE.Mesh(lampGeometry, lampMaterial);

        // Position the lamp elements
        lampCube.position.y = -1; // Anchor point at the top

        // Add to the lamp group
        lamp.add(lampCube);

        return lamp;
      }

      // Create the roof for the cornel box
      function createCornelRoof() {
        // Create the roof group
        const roof = new THREE.Object3D();

        // Create the upper panel
        const panelGeometry = new THREE.BoxGeometry(28, 0.5, 28);
        const panelMaterial = new THREE.MeshLambertMaterial({ color: "#ffffff" });
        const upperPanel = new THREE.Mesh(panelGeometry, panelMaterial);

        // Create the roof frames (h=horizontal, v=vertical, c=center)
        const hLength = 28;
        const vLength = 28 / 3;
        const hFrame1 = createFramePiece(hLength);
        const hFrame2 = createFramePiece(hLength);
        const vFrame1 = createFramePiece(vLength);
        const vFrame2 = createFramePiece(vLength);
        const cFrame1 = createFramePiece(vLength);
        const cFrame2 = createFramePiece(vLength);

        // Create the lamp
        const lamp = createLamp();

        // Position the upper panel
        upperPanel.position.y = 0.25;

        // Position the roof frames
        // TODO: check the calculations. Lengths are too big
        const offset = 0.25; // Offset = half the width of the frame (1)
        hFrame1.rotation.z = Math.PI / 2;
        hFrame1.position.set(hLength / 2, 0, vLength / 2 - offset);
        hFrame2.rotation.z = Math.PI / 2;
        hFrame2.position.set(hLength / 2, 0, -vLength / 2 + offset);
        vFrame1.rotation.x = Math.PI / 2;
        vFrame1.position.set(-hLength / 4, 0, -vLength / 2);
        vFrame2.rotation.x = Math.PI / 2;
        vFrame2.position.set(hLength / 4, 0, -vLength / 2);
        cFrame1.rotation.x = Math.PI / 2;
        cFrame1.position.z = vLength / 2 + offset;
        cFrame2.rotation.x = -Math.PI / 2;
        cFrame2.position.z = -vLength / 2 - offset;

        // Add to the roof group
        roof.add(upperPanel);
        roof.add(hFrame1);
        roof.add(hFrame2);
        roof.add(vFrame1);
        roof.add(vFrame2);
        roof.add(cFrame1);
        roof.add(cFrame2);
        roof.add(lamp);
        return roof;
      }

      // Create a cornel box based on the Telelumen lighting system in the IXR platform in UJM
      function createCornelBox(name = "cornelBox") {
        // Create the cornel box group
        const cornelBox = new THREE.Object3D();
        cornelBox.name = name;

        // Create the cornel box faces
        const frontFace = createCornelFace();
        const leftFace = frontFace.clone();
        const rightFace = frontFace.clone();
        const backFace = frontFace.clone();

        // Create the cornel box roof
        const roof = createCornelRoof();

        // Position the cornel box elements
        frontFace.position.z = 14.5;
        leftFace.position.x = -14.5;
        rightFace.position.x = 14.5;
        backFace.position.z = -14.5;
        roof.position.y = 29.5;

        // Rotate cornel box elements
        leftFace.rotation.y = -Math.PI / 2;
        rightFace.rotation.y = Math.PI / 2;
        backFace.rotation.y = -Math.PI;

        // Scene graph: build the scene here
        cornelBox.add(frontFace);
        cornelBox.add(leftFace);
        cornelBox.add(rightFace);
        cornelBox.add(backFace);
        cornelBox.add(roof);

        return cornelBox;
      }

      // Animate the cornel box
      function animateCornelBox() {}

      // Create a table
      function createTable() {
        // Create the table group
        const table = new THREE.Object3D();

        // Create the material
        const material = new THREE.MeshLambertMaterial({ color: "#808080" });

        // Create the top
        const topGeometry = new THREE.BoxGeometry(10, 0.5, 5);
        const top = new THREE.Mesh(topGeometry, material);

        // Create the legs
        const legGeometry = new THREE.BoxGeometry(0.5, 5, 0.5);
        const lLeg1 = new THREE.Mesh(legGeometry, material);
        const lLeg2 = new THREE.Mesh(legGeometry, material);
        const rLeg1 = new THREE.Mesh(legGeometry, material);
        const rLeg2 = new THREE.Mesh(legGeometry, material);

        // Position the table elements
        top.position.y = 5;
        lLeg1.position.set(-4.5, 2.5, -2);
        lLeg2.position.set(-4.5, 2.5, 2);
        rLeg1.position.set(4.5, 2.5, -2);
        rLeg2.position.set(4.5, 2.5, 2);

        // Fix legs to the table
        table.add(top);
        table.add(lLeg1);
        table.add(lLeg2);
        table.add(rLeg1);
        table.add(rLeg2);

        return table;
      }

      // Create the GUI
      function createGUI() {
        const gui = new GUI();
        return gui;
      }

      // Traverse all children nodes of a parent node
      function traverse(node, f) {
        f(node);
        node.children.forEach((nextNode) => {
          traverse(nextNode, f);
        });
      }

      // Enable shadows for object
      function enableShadows(obj) {
        // Warning: very computationally costly
        if (obj.isMesh === true) {
          obj.castShadow = true;
          obj.receiveShadow = true;
        }
      }

      // Enable transparency for object meshes
      function enableTransparency(obj) {
        if (obj.isMesh === true) {
          obj.material.transparent = true;
          obj.material.opacity = 0.5;
        }
      }

      // Setup VR
      function setupVR() {
        // Enable XR
        renderer.xr.enabled = true;

        // Add XR button
        document.body.appendChild(VRButton.createButton(renderer));

        // Controller setup
        const controllerModelFactory = new XRControllerModelFactory();
        const controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);
        const controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);
      }

      /* FROM PREVIOUS EXERCISES */
      // Fix window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Create a cross using a Line. `opacity` defines its opacity
      function createCross(opacity) {
        const material = new THREE.LineBasicMaterial({
          color: 0xffffff,
          opacity: opacity,
          transparent: true,
        });
        const points = [];
        points.push(new THREE.Vector3(1, 0, 0));
        points.push(new THREE.Vector3(-1, 0, 0));
        points.push(new THREE.Vector3(0, 0, 0));
        points.push(new THREE.Vector3(0, 0, 1));
        points.push(new THREE.Vector3(0, 0, -1));
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const cross = new THREE.Line(geometry, material);
        return cross;
      }

      // Create a floor of crosses
      function floorOfCrosses(FADE_START = 100, FADE_END = 200) {
        /*
        `FADE_START`:Minimum distance from center with opacity=1
        `FADE_END`: Distance from center at which opacity=0
        */
        const floor = new THREE.Object3D();
        scene.add(floor);
        floor.position.y = 0.1;
        // Loop through x and z axis from -50 to +50, so that the floor center is at (0,0,0)
        for (let x = -50; x < 50; x++) {
          // x axis
          for (let z = -50; z < 50; z++) {
            // z axis
            const x_pos = x * 10; // Scale up by 10
            const z_pos = z * 10; // Scale up by 10
            // Calculate distance from center to determine cross opacity. This create a fading effect in a round area around the center
            const radius = Math.sqrt(Math.pow(x_pos, 2) + Math.pow(z_pos, 2));
            const FADE_RANGE = FADE_END - FADE_START; // Range of progressive fade
            let crossOpacity;
            if (radius < FADE_START) {
              // Show cross with full opacity when its under the minimum distance
              crossOpacity = 1;
            } else {
              // Progressive opacity reduction the further from the center it is
              const distance = radius - FADE_START; // Distance from start of fade
              crossOpacity = 1 - distance / FADE_RANGE;
            }
            // Create and position the cross
            const cross = createCross(crossOpacity);
            cross.position.x = x_pos;
            cross.position.z = z_pos;
            // Add the cross to the floor as a child
            floor.add(cross);
          }
        }
      }
    </script>
  </body>
</html>
