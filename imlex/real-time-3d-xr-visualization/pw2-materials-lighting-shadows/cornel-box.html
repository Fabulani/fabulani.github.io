<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Cornel Box</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #c {
        width: 100%;
        height: 100%;
        display: block;
      }

      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display: block;
      }
    </style>
  </head>
  <body>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { VRButton } from "three/addons/webxr/VRButton.js";
      import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";

      /* Main script */
      let camera, globalScene, scene, renderer, controls;

      // Initialize empty scene with cameras and controls
      init();

      // Enable VR
      // setupVR();

      // Create the floor of crosses
      floorOfCrosses(25, 50);

      // Create scene entities
      const cornelBox = createCornelBox();
      const table = createTable();
      const cone = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 32), new THREE.MeshLambertMaterial());
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshPhysicalMaterial());
      const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 32), new THREE.MeshPhongMaterial());

      // Name entities
      table.name = "table";
      cone.name = "cone";
      sphere.name = "sphere";
      cylinder.name = "cylinder";

      // Position the scene entities
      cone.position.set(-3, 6, -1);
      sphere.position.set(0, 6.25, 1);
      cylinder.position.set(3, 6, -1);

      // TODO: CHECK MESHSTANDARDMATERIAL IN 3.JS DOCS

      // Add to the scene
      scene.add(cornelBox);
      scene.add(table);
      scene.add(cone);
      scene.add(sphere);
      scene.add(cylinder);

      // Hide front screen lowerer of the Cornel Box
      scene.getObjectByName("cornelBox_frontCornelFace_screenLowerer").visible = false;

      // Setup the GUI
      setupGUI();

      //! DEBUG ONLY: make everything transparent
      // traverse(cornelBox, enableTransparency);

      // Enable shadows
      traverse(scene.getObjectByName("cornelBox"), enableShadows);
      traverse(scene.getObjectByName("table"), enableShadows);
      traverse(scene.getObjectByName("cone"), enableShadows);
      const c = scene.getObjectByName("lampCube"); // TODO: fix this
      c.enableShadows = false;
      c.castShadow = false;

      // Render with setAnimationLoop for XR compatibility
      renderer.setAnimationLoop(function (time) {
        // Update controls
        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

        // Conel box wall animation
        animateCornelBox();

        // Render
        renderer.render(scene, camera);
      });
      /* End of main script */

      // Initialize empty scene with renderer, cameras, lights, and controls
      function init() {
        // Global scene
        scene = new THREE.Scene();

        // Renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Shadows

        // Cameras
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 500);
        camera.position.set(0, 10.5, 14);

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window); // optional
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 0;
        controls.maxDistance = 500;
        controls.target = new THREE.Vector3(0, 10, 0);
        // controls.autoRotate = true;
        controls.autoRotateSpeed = 1;

        // Lights
        {
          const color = 0xffffff;
          const intensity = 0.2;
          const light = new THREE.AmbientLight(color, intensity);
          light.name = "ambientLight";
          scene.add(light);
        }

        // Additional setup
        document.body.appendChild(renderer.domElement);

        // Window resize fix
        window.addEventListener("resize", onWindowResize);

        // Add a simple floor
        const floor = new THREE.Mesh(
          new THREE.BoxGeometry(100, 0.01, 100),
          new THREE.MeshBasicMaterial({ color: "gray" })
        );
        scene.add(floor);
        // TODO: fix this, shadows not working for the floor
        floor.enableShadows = true;
        floor.castShadow = true;
      }

      // Create a frame piece (metallic lengthy component with fringes)
      function createFramePiece(length) {
        // Create the frame piece group.
        const framePiece = new THREE.Object3D();

        // Create the materials
        const material = new THREE.MeshLambertMaterial({ color: "#AAAFBA" });

        // Create the corners (perspective: top-view).
        const cornerWidth = 0.21875; // Calculated to sum-up with centers and fringes to 1
        const cornerGeometry = new THREE.BoxGeometry(cornerWidth, length, cornerWidth);
        const bLeftCorner = new THREE.Mesh(cornerGeometry, material);
        const bRightCorner = bLeftCorner.clone();
        const tLeftCorner = bLeftCorner.clone();
        const tRightCorner = bLeftCorner.clone();

        // Create the centers
        const centerWidth = cornerWidth * 2;
        const centerGeometry = new THREE.BoxGeometry(cornerWidth * 2, length, 1);
        const frontCenter = new THREE.Mesh(centerGeometry, material);
        const sideCenter = new THREE.Mesh(centerGeometry, material);

        // Create the filler
        const fillerWidth = 1 - cornerWidth;
        const fillerGeometry = new THREE.BoxGeometry(fillerWidth, length - 0.001, fillerWidth);
        const filler = new THREE.Mesh(fillerGeometry, material);

        // Position the corners
        const cornerPos = 0.5 - cornerWidth / 2;
        bLeftCorner.position.set(-cornerPos, length / 2, cornerPos);
        bRightCorner.position.set(cornerPos, length / 2, cornerPos);
        tLeftCorner.position.set(-cornerPos, length / 2, -cornerPos);
        tRightCorner.position.set(cornerPos, length / 2, -cornerPos);

        // Position the centers
        frontCenter.position.y = length / 2;
        sideCenter.position.y = length / 2;
        sideCenter.rotation.y = Math.PI / 2;

        // Position the filler
        filler.position.y = length / 2;

        // Add corners, centers, and filler to the frame piece
        framePiece.add(bLeftCorner);
        framePiece.add(bRightCorner);
        framePiece.add(tLeftCorner);
        framePiece.add(tRightCorner);
        framePiece.add(frontCenter);
        framePiece.add(sideCenter);
        framePiece.add(filler);
        return framePiece;
      }

      // Create a panel (yellow front face, white back face)
      function createPanel(name = "panel") {
        // Create the panel group
        const panel = new THREE.Object3D();

        // Cornel box measurements
        const fringeLength = 0.0625;
        const cornerWidth = 0.21875;

        // Create the front and back faces according to the cornel box measurements
        const panelGeometry = new THREE.BoxGeometry(28, 3, fringeLength / 2);
        const panelMaterials = [
          // Front and Back
          new THREE.MeshLambertMaterial({ color: "#909B21" }),
          new THREE.MeshLambertMaterial({ color: "#ffffff" }),
        ];
        const panelFront = new THREE.Mesh(panelGeometry, panelMaterials[0]);
        const panelBack = new THREE.Mesh(panelGeometry, panelMaterials[1]);
        panelBack.name = name + "_back";

        // Distance the front and back faces
        panelFront.position.z = fringeLength / 2;
        panelBack.position.z = -fringeLength / 2;

        // Add front and back to the panel group
        panel.add(panelFront);
        panel.add(panelBack);

        return panel;
      }

      // Create a screen lowerer
      function createScreenLowerer(name) {
        // Create the screen lowerer group
        const screenLowerer = new THREE.Object3D();
        screenLowerer.name = name;

        // Cornel box measurements
        const fringeLength = 0.0625;
        const cornerWidth = 0.21875;

        // Create the material
        const material = new THREE.MeshLambertMaterial({ color: "#5F6062" });
        const screenMaterial = new THREE.MeshLambertMaterial({ color: "#ffffff" });

        // Create the top frame
        // TODO: gap for side frame and screen, hole detail in the back face
        const tFrameGeometry = new THREE.BoxGeometry(28, 1, 1);
        const tFrame = new THREE.Mesh(tFrameGeometry, material);

        // Create the side frames of the screen lowerer
        // TODO: side frames have a gap for the screen, with the gap filled with brush hair, and a offset detail
        const sFrameGeometry = new THREE.BoxGeometry(0.5, 24, fringeLength + cornerWidth);
        const lFrame = new THREE.Mesh(sFrameGeometry, material);
        const rFrame = new THREE.Mesh(sFrameGeometry, material);

        // Create the screen
        // TODO: bottom part of the screen is bigger than the screen panel + check calculations
        // TODO: frontface of the panel is black / dark gray, back face is white
        const screen = new THREE.Object3D();
        const screenPanelGeometry = new THREE.BoxGeometry(28 - 2 * cornerWidth, 24 - 2 * cornerWidth, fringeLength / 2);
        const screenBottomGeometry = new THREE.BoxGeometry(28 - 2 * cornerWidth, 2 * cornerWidth, fringeLength);
        const screenPanel = new THREE.Mesh(screenPanelGeometry, screenMaterial);
        const screenBottom = new THREE.Mesh(screenBottomGeometry, material);
        screen.name = name + "_screen";
        screenPanel.name = name + "_screenPanel";
        screenBottom.name = name + "_screenBottom";

        // Position the screen parts
        screenBottom.position.y = cornerWidth;
        screenPanel.position.y = 12 + cornerWidth;

        // Add screen parts to the screen group
        screen.add(screenPanel);
        screen.add(screenBottom);

        // Position the frames and the screen
        const innerFringePosition = -(cornerWidth + fringeLength / 2);
        tFrame.position.y = 24.5;
        lFrame.position.set(-14, 12, innerFringePosition);
        rFrame.position.set(14, 12, innerFringePosition);

        // Add parts to the group
        screenLowerer.add(tFrame);
        screenLowerer.add(lFrame);
        screenLowerer.add(rFrame);
        screenLowerer.add(screenBottom);
        screenLowerer.add(screen);

        return screenLowerer;
      }

      // Create one face of the cornel box
      function createCornelFace(name = "cornelFace") {
        // Create the face group
        const face = new THREE.Object3D();
        face.name = name;

        // Create the frames
        const lFramePiece = createFramePiece(29.5);
        const rFramePiece = createFramePiece(29.5);
        const tFramePiece = createFramePiece(28);
        const bFramePiece = createFramePiece(28);

        // Create the panel
        const panel = createPanel(name + "_panel");

        // Create the screen lowerer
        const screenLowerer = createScreenLowerer(name + "_screenLowerer");

        // Position the frames
        lFramePiece.position.set(-14.5, 0.5, 0);
        rFramePiece.position.set(14.5, 0.5, 0);
        tFramePiece.position.set(-14, 29.5, 0);
        tFramePiece.rotation.z = -Math.PI / 2;
        bFramePiece.position.set(-14, 25.5, 0); // Check the y position calculations
        bFramePiece.rotation.z = -Math.PI / 2;

        // Position the panel on the outermost fringe CHECK CALCULATIONS
        const fringeLength = 0.0625;
        const cornerWidth = 0.21875;
        panel.position.set(0, 27.5, cornerWidth + fringeLength / 2);

        // Add components to the face
        face.add(lFramePiece);
        face.add(rFramePiece);
        face.add(tFramePiece);
        face.add(bFramePiece);
        face.add(panel);
        face.add(screenLowerer);

        return face;
      }

      // Create the roof lamp
      // TODO: make the lamp model
      function createLamp(name = "lamp") {
        // Create the lamp group
        const lamp = new THREE.Object3D();

        // Create a placeholder cube for the lamp
        const lampMaterial = new THREE.MeshLambertMaterial({ color: "#ffffff" });
        const lampGeometry = new THREE.BoxGeometry(1, 1, 1);
        const lampCube = new THREE.Mesh(lampGeometry, lampMaterial);
        lampCube.name = "lampCube";

        // Position the lamp elements
        lampCube.position.y = -1; // Anchor point at the top

        // Directional Light
        const directionalColor = 0xffffff;
        const directionalIntensity = 0.25;
        const directionalLight = new THREE.DirectionalLight(directionalColor, directionalIntensity);
        directionalLight.name = name + "_directionalLight";
        directionalLight.target = scene;

        // Point light
        const pointColor = 0xff0000;
        const pointIntensity = 0.25;
        const pointDistance = 100;
        const pointDecay = 2;
        const pointLight = new THREE.PointLight(pointColor, pointIntensity, pointDistance, pointDecay);
        pointLight.name = name + "_pointLight";

        // Spotlight
        const spotLight = new THREE.SpotLight(0xffffff, 0.25);
        spotLight.name = name + "_spotLight";
        spotLight.target = scene;

        // Hemisphere light
        const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.25);
        hemisphereLight.name = name + "_hemisphereLight";

        // Add to the lamp group
        lamp.add(lampCube);
        lamp.add(directionalLight);
        lamp.add(pointLight);
        lamp.add(spotLight);
        lamp.add(hemisphereLight);

        return lamp;
      }

      // Create the roof for the cornel box
      function createCornelRoof(name = "roof") {
        // Create the roof group
        const roof = new THREE.Object3D();

        // Create the upper panel
        const panelGeometry = new THREE.BoxGeometry(28, 0.5, 28);
        const panelMaterial = new THREE.MeshLambertMaterial({ color: "#ffffff" });
        const upperPanel = new THREE.Mesh(panelGeometry, panelMaterial);
        upperPanel.name = name + "_upperPanel";

        // Create the roof frames (h=horizontal, v=vertical, c=center)
        const hLength = 28;
        const vLength = 28 / 3;
        const hFrame1 = createFramePiece(hLength);
        const hFrame2 = createFramePiece(hLength);
        const vFrame1 = createFramePiece(vLength);
        const vFrame2 = createFramePiece(vLength);
        const cFrame1 = createFramePiece(vLength);
        const cFrame2 = createFramePiece(vLength);

        // Create the lamp
        const lamp = createLamp(name + "_lamp");

        // DEBUG
        const axesHelper = new THREE.AxesHelper(5);
        lamp.add(axesHelper);

        // Position the upper panel
        upperPanel.position.y = 0.25;

        // Position the roof frames (y=-0.01 to avoid flickering with panel)
        // TODO: check the calculations. Lengths are too big
        const offset = 0.25; // Offset = half the width of the frame (1)
        hFrame1.rotation.z = Math.PI / 2;
        hFrame1.position.set(hLength / 2, -0.01, vLength / 2 - offset);
        hFrame2.rotation.z = Math.PI / 2;
        hFrame2.position.set(hLength / 2, -0.01, -vLength / 2 + offset);
        vFrame1.rotation.x = Math.PI / 2;
        vFrame1.position.set(-hLength / 4, -0.01, -vLength / 2);
        vFrame2.rotation.x = Math.PI / 2;
        vFrame2.position.set(hLength / 4, -0.01, -vLength / 2);
        cFrame1.rotation.x = Math.PI / 2;
        cFrame1.position.set(0, -0.01, vLength / 2 + offset);
        cFrame2.rotation.x = -Math.PI / 2;
        cFrame2.position.set(0, -0.01, -vLength / 2 - offset);

        // Add to the roof group
        roof.add(upperPanel);
        roof.add(hFrame1);
        roof.add(hFrame2);
        roof.add(vFrame1);
        roof.add(vFrame2);
        roof.add(cFrame1);
        roof.add(cFrame2);
        roof.add(lamp);
        return roof;
      }

      // Create a cornel box based on the Telelumen lighting system in the IXR platform in UJM
      function createCornelBox(name = "cornelBox") {
        // Create the cornel box group
        const cornelBox = new THREE.Object3D();
        cornelBox.name = name;

        // Create the cornel box faces
        const frontFace = createCornelFace(name + "_frontCornelFace");
        const leftFace = createCornelFace(name + "_leftCornelFace");
        const rightFace = createCornelFace(name + "_rightCornelFace");
        const backFace = createCornelFace(name + "_backCornelFace");

        // Create the cornel box roof
        const roof = createCornelRoof(name + "_roof");

        // Position the cornel box elements
        frontFace.position.z = 14.5;
        leftFace.position.x = -14.5;
        rightFace.position.x = 14.5;
        backFace.position.z = -14.5;
        roof.position.y = 29.5;

        // Rotate cornel box elements
        leftFace.rotation.y = -Math.PI / 2;
        rightFace.rotation.y = Math.PI / 2;
        backFace.rotation.y = -Math.PI;

        // Scene graph: build the scene here
        cornelBox.add(frontFace);
        cornelBox.add(leftFace);
        cornelBox.add(rightFace);
        cornelBox.add(backFace);
        cornelBox.add(roof);

        return cornelBox;
      }

      // Animate the cornel box
      function animateCornelBox() {}

      // Create a table
      function createTable() {
        // Create the table group
        const table = new THREE.Object3D();
        table.name = "name";

        // Create the material
        const material = new THREE.MeshLambertMaterial({ color: "#808080" });

        // Create the top
        const topGeometry = new THREE.BoxGeometry(10, 0.5, 5);
        const top = new THREE.Mesh(topGeometry, material);

        // Create the legs
        const legGeometry = new THREE.BoxGeometry(0.5, 5, 0.5);
        const lLeg1 = new THREE.Mesh(legGeometry, material);
        const lLeg2 = new THREE.Mesh(legGeometry, material);
        const rLeg1 = new THREE.Mesh(legGeometry, material);
        const rLeg2 = new THREE.Mesh(legGeometry, material);

        // Position the table elements
        top.position.y = 5;
        lLeg1.position.set(-4.5, 2.5, -2);
        lLeg2.position.set(-4.5, 2.5, 2);
        rLeg1.position.set(4.5, 2.5, -2);
        rLeg2.position.set(4.5, 2.5, 2);

        // Fix legs to the table
        table.add(top);
        table.add(lLeg1);
        table.add(lLeg2);
        table.add(rLeg1);
        table.add(rLeg2);

        return table;
      }

      // Setup the GUI
      function setupGUI() {
        // Top level controller
        const gui = new GUI({ title: "Cornel Settings" });

        // Get references
        const frontPanel = scene.getObjectByName("cornelBox_frontCornelFace_screenLowerer_screenPanel");
        const leftPanel = scene.getObjectByName("cornelBox_leftCornelFace_screenLowerer_screenPanel");
        const rightPanel = scene.getObjectByName("cornelBox_rightCornelFace_screenLowerer_screenPanel");
        const backPanel = scene.getObjectByName("cornelBox_backCornelFace_screenLowerer_screenPanel");
        const frontScreenLowerer = scene.getObjectByName("cornelBox_frontCornelFace_screenLowerer");
        const leftScreenLowerer = scene.getObjectByName("cornelBox_leftCornelFace_screenLowerer");
        const rightScreenLowerer = scene.getObjectByName("cornelBox_rightCornelFace_screenLowerer");
        const backScreenLowerer = scene.getObjectByName("cornelBox_backCornelFace_screenLowerer");
        const frontTopPanel = scene.getObjectByName("cornelBox_frontCornelFace_panel_back");
        const leftTopPanel = scene.getObjectByName("cornelBox_leftCornelFace_panel_back");
        const rightTopPanel = scene.getObjectByName("cornelBox_rightCornelFace_panel_back");
        const backTopPanel = scene.getObjectByName("cornelBox_backCornelFace_panel_back");
        const roofPanel = scene.getObjectByName("cornelBox_roof_upperPanel");
        const directionalLight = scene.getObjectByName("cornelBox_roof_lamp_directionalLight");
        const pointLight = scene.getObjectByName("cornelBox_roof_lamp_pointLight");
        const spotLight = scene.getObjectByName("cornelBox_roof_lamp_spotLight");
        const hemisphereLight = scene.getObjectByName("cornelBox_roof_lamp_hemisphereLight");

        // Settings for the gui
        const settings = {
          // Enable/disable screen lowerers
          enableFrontScreenLowerer: frontScreenLowerer.visible,
          enableLeftScreenLowerer: leftScreenLowerer.visible,
          enableRightScreenLowerer: rightScreenLowerer.visible,
          enableBackScreenLowerer: backScreenLowerer.visible,

          // Panel material
          frontPanelColor: frontPanel.material.color,
          leftPanelColor: leftPanel.material.color,
          rightPanelColor: rightPanel.material.color,
          backPanelColor: backPanel.material.color,
          roofPanel: roofPanel.material.color,

          // Checkboxes for enabling different types of lights
          directionalLightEnable: directionalLight.visible,
          pointLightEnable: pointLight.visible,
          spotLightEnable: spotLight.visible,
          hemisphereLightEnable: hemisphereLight.visible,

          // Light intensities
          directionalLightIntensity: directionalLight.intensity,
          pointLightIntensity: pointLight.intensity,
          spotLightIntensity: spotLight.intensity,
          hemisphereLightIntensity: hemisphereLight.intensity,

          // Light colors
          directionalLightColor: directionalLight.color,
          pointLightColor: pointLight.color,
          spotLightColor: spotLight.color,
          hemisphereLightColor: hemisphereLight.color,

          // Directional light specific settings
          directionalLightCastShadow: directionalLight.castShadow,
          directionalLightTarget: directionalLight.target,

          // Point light specific settings
          pointLightCastShadow: pointLight.castShadow,
          pointLightDecay: pointLight.decay,
          pointLightDistance: pointLight.distance,
          pointLightPower: pointLight.power,

          // Spot light specific settings
          spotLightAngle: spotLight.angle * (180 / Math.PI),
          spotLightCastShadow: spotLight.castShadow,
          spotLightDecay: spotLight.decay,
          spotLightDistance: spotLight.distance,
          spotLightPenumbra: spotLight.penumbra,
          spotLightPower: spotLight.power,
          spotLightTarget: spotLight.target,
          spotLightMap: spotLight.map,

          // Hemisphere light specific settings
          hemisphereLightGroundColor: hemisphereLight.groundColor,
        };

        // Top-level folder for structure related folders
        const folderStructure = gui.addFolder("Structure");
        folderStructure.close();

        // Screen lowerer settings
        const folderScreenLowerer = folderStructure.addFolder("Screen Lowerers");
        folderScreenLowerer
          .add(settings, "enableFrontScreenLowerer")
          .name("Enable front")
          .onChange((toggle) => {
            frontScreenLowerer.visible = toggle;
          });
        folderScreenLowerer
          .add(settings, "enableLeftScreenLowerer")
          .name("Enable left")
          .onChange((toggle) => {
            leftScreenLowerer.visible = toggle;
          });
        folderScreenLowerer
          .add(settings, "enableRightScreenLowerer")
          .name("Enable right")
          .onChange((toggle) => {
            rightScreenLowerer.visible = toggle;
          });
        folderScreenLowerer
          .add(settings, "enableBackScreenLowerer")
          .name("Enable back")
          .onChange((toggle) => {
            backScreenLowerer.visible = toggle;
          });

        // Panel settings
        const folderPanels = folderStructure.addFolder("Panels");
        folderPanels
          .addColor(settings, "frontPanelColor")
          .name("Front")
          .onChange((color) => {
            frontPanel.material.color.set(color);
            frontTopPanel.material.color.set(color);
          });
        folderPanels
          .addColor(settings, "leftPanelColor")
          .name("Left")
          .onChange((color) => {
            leftPanel.material.color.set(color);
            leftTopPanel.material.color.set(color);
          });
        folderPanels
          .addColor(settings, "rightPanelColor")
          .name("Right")
          .onChange((color) => {
            rightPanel.material.color.set(color);
            rightTopPanel.material.color.set(color);
          });
        folderPanels
          .addColor(settings, "backPanelColor")
          .name("Back")
          .onChange((color) => {
            backPanel.material.color.set(color);
            backTopPanel.material.color.set(color);
          });
        folderPanels
          .addColor(settings, "roofPanel")
          .name("Roof")
          .onChange((color) => {
            roofPanel.material.color.set(color);
          });

        // Lights folders
        const folderLights = gui.addFolder("Lights");
        folderLights.close();
        const folderDirectionalLight = folderLights.addFolder("Directional Light");
        const folderPointLight = folderLights.addFolder("Point Light");
        const folderSpotLight = folderLights.addFolder("Spot Light");
        const folderHemisphereLight = folderLights.addFolder("Hemisphere Light");

        // Helper object to add common light settings
        // TODO: add ambient light
        const lights = [
          {
            folder: folderDirectionalLight,
            ref: directionalLight,
            prefix: "directionalLight",
          },
          {
            folder: folderPointLight,
            ref: pointLight,
            prefix: "pointLight",
          },
          {
            folder: folderSpotLight,
            ref: spotLight,
            prefix: "spotLight",
          },
          {
            folder: folderHemisphereLight,
            ref: hemisphereLight,
            prefix: "hemisphereLight",
          },
        ];

        function addCommonLightSettings(light) {
          // Add light settings to the gui
          const folder = light["folder"];
          const ref = light["ref"];
          const prefix = light["prefix"];
          folder
            .add(settings, prefix + "Enable")
            .name("Enable")
            .onChange((toggle) => {
              ref.visible = toggle;
            });
          folder
            .add(settings, prefix + "Intensity")
            .min(0)
            .max(1)
            .name("Intensity")
            .onChange((intensity) => {
              ref.intensity = intensity;
            });
          folder
            .addColor(settings, prefix + "Color")
            .name("Color")
            .onChange((color) => {
              ref.color = color;
            });
        }

        // Add common settings for each light
        lights.forEach((light) => {
          addCommonLightSettings(light);
        });

        // Add other directional light settings
        folderDirectionalLight
          .add(settings, "directionalLightCastShadow")
          .name("Cast shadows")
          .onChange((toggle) => {
            directionalLight.castShadow = toggle;
          });
        folderDirectionalLight
          .add(settings, "directionalLightTarget", {
            Scene: scene,
            Table: table,
            Cone: cone,
            Sphere: sphere,
            Cylinder: cylinder,
          })
          .name("Target")
          .onChange((tgt) => {
            directionalLight.target = tgt;
          });

        // Add other point light settings
        folderPointLight
          .add(settings, "pointLightCastShadow")
          .name("Cast shadows")
          .onChange((toggle) => {
            pointLight.castShadow = toggle;
          });
        // TODO: In context of physically-correct rendering the default value (2) should not be changed.
        folderPointLight
          .add(settings, "pointLightDecay")
          .min(0)
          .max(100)
          .name("Decay")
          .onChange((value) => {
            pointLight.decay = value;
          });
        folderPointLight
          .add(settings, "pointLightDistance")
          .min(0)
          .max(100)
          .name("Distance")
          .onChange((value) => {
            pointLight.distance = value;
          });
        folderPointLight
          .add(settings, "pointLightPower")
          .min(0)
          .max(100)
          .name("Power")
          .onChange((value) => {
            pointLight.power = value;
          });

        // TODO: NEXT STEPS HERE!

        // Add other spot light settings
        folderSpotLight
          .add(settings, "spotLightAngle")
          .min(0)
          .max(180)
          .name("Angle (degrees)")
          .onChange((value) => {
            spotLight.angle = value * (Math.PI / 180);
          });
        folderSpotLight
          .add(settings, "spotLightCastShadow")
          .name("Cast shadow")
          .onChange((toggle) => {
            spotLight.castShadow = toggle;
          });
        folderSpotLight
          .add(settings, "spotLightDecay")
          .min(0)
          .max(100)
          .name("Decay")
          .onChange((value) => {
            spotLight.decay = value;
          });
        folderSpotLight
          .add(settings, "spotLightDistance")
          .min(0)
          .max(100)
          .name("Distance")
          .onChange((value) => {
            spotLight.distance = value;
          });
        folderSpotLight
          .add(settings, "spotLightPenumbra")
          .min(0)
          .max(1)
          .name("Penumbra")
          .onChange((value) => {
            spotLight.penumbra = value;
          });
        folderSpotLight
          .add(settings, "spotLightPower")
          .min(0)
          .max(100)
          .name("Power")
          .onChange((value) => {
            spotLight.power = value;
          });
        folderSpotLight
          .add(settings, "spotLightTarget", {
            Scene: scene,
            Table: table,
            Cone: cone,
            Sphere: sphere,
            Cylinder: cylinder,
          })
          .name("Target")
          .onChange((tgt) => {
            spotLight.target = tgt;
          });

        // Add other hemisphere light settings
        folderHemisphereLight
          .addColor(settings, "hemisphereLightGroundColor")
          .name("Ground color")
          .onChange((color) => {
            hemisphereLight.groundColor = color;
          });

        // TODO: add other ambient light settings

        // TODO: for VR, place the gui as an object with listeners for sessionStart and sessionEnd so it only shows up in VR
      }

      // Traverse all children nodes of a parent node
      function traverse(node, f) {
        f(node);
        node.children.forEach((nextNode) => {
          traverse(nextNode, f);
        });
      }

      // Enable shadows for object
      function enableShadows(obj) {
        // Warning: very computationally costly
        if (obj.isMesh === true) {
          obj.castShadow = true;
          obj.receiveShadow = true;
        }
      }

      // Enable transparency for object meshes
      function enableTransparency(obj) {
        if (obj.isMesh === true) {
          obj.material.transparent = true;
          obj.material.opacity = 0.5;
        }
      }

      // Setup VR
      function setupVR() {
        // Enable XR
        renderer.xr.enabled = true;

        // Add XR button
        document.body.appendChild(VRButton.createButton(renderer));

        // Controller setup
        const controllerModelFactory = new XRControllerModelFactory();
        const controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);
        const controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);
      }

      /* FROM PREVIOUS EXERCISES */
      // Fix window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Create a cross using a Line. `opacity` defines its opacity
      function createCross(opacity) {
        const material = new THREE.LineBasicMaterial({
          color: 0xffffff,
          opacity: opacity,
          transparent: true,
        });
        const points = [];
        points.push(new THREE.Vector3(1, 0, 0));
        points.push(new THREE.Vector3(-1, 0, 0));
        points.push(new THREE.Vector3(0, 0, 0));
        points.push(new THREE.Vector3(0, 0, 1));
        points.push(new THREE.Vector3(0, 0, -1));
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const cross = new THREE.Line(geometry, material);
        return cross;
      }

      // Create a floor of crosses
      function floorOfCrosses(FADE_START = 100, FADE_END = 200) {
        /*
        `FADE_START`:Minimum distance from center with opacity=1
        `FADE_END`: Distance from center at which opacity=0
        */
        const floor = new THREE.Object3D();
        scene.add(floor);
        floor.position.y = 0.1;
        // Loop through x and z axis from -50 to +50, so that the floor center is at (0,0,0)
        for (let x = -50; x < 50; x++) {
          // x axis
          for (let z = -50; z < 50; z++) {
            // z axis
            const x_pos = x * 10; // Scale up by 10
            const z_pos = z * 10; // Scale up by 10
            // Calculate distance from center to determine cross opacity. This create a fading effect in a round area around the center
            const radius = Math.sqrt(Math.pow(x_pos, 2) + Math.pow(z_pos, 2));
            const FADE_RANGE = FADE_END - FADE_START; // Range of progressive fade
            let crossOpacity;
            if (radius < FADE_START) {
              // Show cross with full opacity when its under the minimum distance
              crossOpacity = 1;
            } else {
              // Progressive opacity reduction the further from the center it is
              const distance = radius - FADE_START; // Distance from start of fade
              crossOpacity = 1 - distance / FADE_RANGE;
            }
            // Create and position the cross
            const cross = createCross(crossOpacity);
            cross.position.x = x_pos;
            cross.position.z = z_pos;
            // Add the cross to the floor as a child
            floor.add(cross);
          }
        }
      }
    </script>
  </body>
</html>
